import {
  ACESFilmicToneMapping,
  AmbientLight,
  CineonToneMapping,
  Color,
  DirectionalLight,
  FileLoader,
  HemisphereLight,
  InstancedBufferAttribute,
  LineBasicMaterial,
  LinearEncoding,
  LinearToneMapping,
  Loader,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  MeshBasicMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  NoToneMapping,
  ObjectLoader,
  ObjectSpaceNormalMap,
  PointLight,
  PointsMaterial,
  REVISION,
  ReinhardToneMapping,
  ShaderMaterial,
  SpotLight,
  SpriteMaterial,
  TangentSpaceNormalMap,
  Vector2,
  Vector3,
  Vector4,
  sRGBEncoding
} from "./chunk-5ISMYKQ4.js";
import {
  __export
} from "./chunk-AC2VUBZ6.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
var getCacheKey = (object) => {
  let cacheKey = "{";
  if (object.isNode === true) {
    cacheKey += `uuid:"${object.uuid}",`;
  }
  for (const property2 of getNodesKeys(object)) {
    cacheKey += `${property2}:${object[property2].getCacheKey()},`;
  }
  cacheKey += "}";
  return cacheKey;
};
var getNodesKeys = (object) => {
  const props = [];
  for (const name in object) {
    const value = object[name];
    if (value && value.isNode === true) {
      props.push(name);
    }
  }
  return props;
};
var getValueType = (value) => {
  if (typeof value === "number") {
    return "float";
  } else if (typeof value === "boolean") {
    return "bool";
  } else if (value && value.isVector2 === true) {
    return "vec2";
  } else if (value && value.isVector3 === true) {
    return "vec3";
  } else if (value && value.isVector4 === true) {
    return "vec4";
  } else if (value && value.isMatrix3 === true) {
    return "mat3";
  } else if (value && value.isMatrix4 === true) {
    return "mat4";
  } else if (value && value.isColor === true) {
    return "color";
  }
  return null;
};
var getValueFromType = (type, ...params) => {
  const last4 = type ? type.slice(-4) : void 0;
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  }
  return null;
};

// node_modules/three/examples/jsm/nodes/core/Node.js
var _nodeId = 0;
var Node = class {
  constructor(nodeType = null) {
    this.isNode = true;
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.name;
  }
  isGlobal() {
    return false;
  }
  getChildren() {
    const children = [];
    for (const property2 in this) {
      const object = this[property2];
      if (Array.isArray(object) === true) {
        for (const child of object) {
          if (child && child.isNode === true) {
            children.push(child);
          }
        }
      } else if (object && object.isNode === true) {
        children.push(object);
      } else if (typeof object === "object") {
        for (const property3 in object) {
          const child = object[property3];
          if (child && child.isNode === true) {
            children.push(child);
          }
        }
      }
    }
    return children;
  }
  getCacheKey() {
    return getCacheKey(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  getReference(builder) {
    const hash = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash);
    return nodeFromHash || this;
  }
  construct(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    for (const childNode of this.getChildren()) {
      nodeProperties["_node" + childNode.id] = childNode;
    }
    return null;
  }
  analyze(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    if (nodeData.dependenciesCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output);
    }
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output = null) {
    const refNode = this.getReference(builder);
    if (this !== refNode) {
      return refNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "construct") {
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        properties.initialized = true;
        properties.outputNode = this.construct(builder);
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output);
      } else {
        result = this.generate(builder, output) || "";
      }
    }
    builder.removeStack(this);
    return result;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property2 of nodeKeys) {
        inputNodes[property2] = this[property2].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        const uuid = json.inputNodes[property2];
        this[property2] = nodes[uuid];
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray)
      data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    if (this.value && this.value.fromArray)
      this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type, output);
  }
};
var UniformNode_default = UniformNode;

// node_modules/three/examples/jsm/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.isArrayUniformNode = true;
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
var ArrayUniformNode_default = ArrayUniformNode;

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { name, node } = this;
    const type = this.getNodeType(builder);
    const nodeVarying = builder.getVaryingFromNode(this, type);
    nodeVarying.needsInterpolation || (nodeVarying.needsInterpolation = builder.shaderStage === "fragment");
    if (name !== null) {
      nodeVarying.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVarying, NodeShaderStage.VERTEX);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, node, type, propertyName);
    return builder.getPropertyName(nodeVarying);
  }
};
var VaryingNode_default = VaryingNode;

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    const attributeName = this.getAttributeName(builder);
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromLength(attribute2.itemSize);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const nodeAttribute = builder.getAttribute(attributeName, nodeType);
      if (builder.isShaderStage("vertex")) {
        return nodeAttribute.name;
      } else {
        const nodeVarying = new VaryingNode_default(this);
        return nodeVarying.build(builder, nodeAttribute.type);
      }
    } else {
      console.warn(`Attribute "${attributeName}" not found.`);
      return builder.getConst(nodeType);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
var BypassNode_default = BypassNode;

// node_modules/three/examples/jsm/nodes/core/NodeCache.js
var id = 0;
var NodeCache = class {
  constructor() {
    this.id = id++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(node) {
    return this.nodesData.get(node);
  }
  setNodeData(node, data) {
    this.nodesData.set(node, data);
  }
};
var NodeCache_default = NodeCache;

// node_modules/three/examples/jsm/nodes/core/CacheNode.js
var CacheNode = class extends Node_default {
  constructor(node, cache2 = new NodeCache_default()) {
    super();
    this.isCacheNode = true;
    this.node = node;
    this.cache = cache2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    builder.setCache(this.cache);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var CacheNode_default = CacheNode;

// node_modules/three/examples/jsm/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", includes3 = []) {
    super("code");
    this.isCodeNode = true;
    this.code = code2;
    this._includes = includes3;
  }
  setIncludes(includes3) {
    this._includes = includes3;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes3 = this.getIncludes(builder);
    for (const include of includes3) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
var CodeNode_default = CodeNode;

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output);
  }
};
var ConstNode_default = ConstNode;

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  construct(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;

// node_modules/three/examples/jsm/nodes/core/ExpressionNode.js
var ExpressionNode = class extends Node_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type === "void") {
      builder.addFlowCode(snipped);
    } else {
      return builder.format(`( ${snipped} )`, type, output);
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  hasDependencies(builder) {
    return builder.getDataFromNode(this).dependenciesCount > 1;
  }
  build(builder, output) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output);
      } else if (builder.context.tempWrite !== false && type !== "void " && output !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output);
      }
    }
    return super.build(builder, output);
  }
};
var TempNode_default = TempNode;

// node_modules/three/examples/jsm/nodes/core/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        const inputNode = inputs[i];
        const node = parameters[i];
        params.push(node.build(builder, inputNode.type));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(node.build(builder, inputNode.type));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;

// node_modules/three/examples/jsm/nodes/core/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "", includes3 = []) {
    super(code2, includes3);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  call(parameters = {}) {
    return new FunctionCallNode_default(this, parameters);
  }
  generate(builder, output) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2;
    if (output === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output);
    }
  }
};
var FunctionNode_default = FunctionNode;

// node_modules/three/examples/jsm/nodes/core/InstanceIndexNode.js
var InstanceIndexNode = class extends Node_default {
  constructor() {
    super("uint");
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    return builder.getInstanceIndex();
  }
};
var InstanceIndexNode_default = InstanceIndexNode;

// node_modules/three/examples/jsm/nodes/core/LightingModel.js
var LightingModel = class {
  constructor(direct = null, indirectDiffuse = null, indirectSpecular = null, ambientOcclusion = null) {
    this.direct = direct;
    this.indirectDiffuse = indirectDiffuse;
    this.indirectSpecular = indirectSpecular;
    this.ambientOcclusion = ambientOcclusion;
  }
};
var LightingModel_default = LightingModel;

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
  }
};
var NodeAttribute_default = NodeAttribute;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
var NodeUniform_default = NodeUniform;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVar_default = NodeVar;

// node_modules/three/examples/jsm/nodes/core/NodeVarying.js
var NodeVarying = class extends NodeVar_default {
  constructor(name, type) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
  }
};
var NodeVarying_default = NodeVarying;

// node_modules/three/examples/jsm/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three/examples/jsm/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = [];
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code2) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code2.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code2) {
    const keywordNodes = this.parse(code2);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeElements.js
var ShaderNodeElements_exports = {};
__export(ShaderNodeElements_exports, {
  BRDF_BlinnPhong: () => BRDF_BlinnPhong_default,
  BRDF_GGX: () => BRDF_GGX_default,
  BRDF_Lambert: () => BRDF_Lambert_default,
  DFGApprox: () => DFGApprox_default,
  D_GGX: () => D_GGX_default,
  EPSILON: () => EPSILON,
  F_Schlick: () => F_Schlick_default,
  INFINITY: () => INFINITY,
  ShaderNode: () => ShaderNode,
  TBNViewMatrix: () => TBNViewMatrix,
  V_GGX_SmithCorrelated: () => V_GGX_SmithCorrelated_default,
  abs: () => abs,
  acos: () => acos,
  add: () => add,
  and: () => and,
  asin: () => asin,
  assign: () => assign,
  atan: () => atan,
  atan2: () => atan2,
  attribute: () => attribute,
  bitAnd: () => bitAnd,
  bitOr: () => bitOr,
  bitXor: () => bitXor,
  bitangentGeometry: () => bitangentGeometry,
  bitangentLocal: () => bitangentLocal,
  bitangentView: () => bitangentView,
  bitangentWorld: () => bitangentWorld,
  bmat3: () => bmat3,
  bmat4: () => bmat4,
  bool: () => bool,
  buffer: () => buffer,
  burn: () => burn,
  bvec2: () => bvec2,
  bvec3: () => bvec3,
  bvec4: () => bvec4,
  bypass: () => bypass,
  cache: () => cache,
  call: () => call,
  cameraNormalMatrix: () => cameraNormalMatrix,
  cameraPosition: () => cameraPosition,
  cameraProjectionMatrix: () => cameraProjectionMatrix,
  cameraViewMatrix: () => cameraViewMatrix,
  cameraWorldMatrix: () => cameraWorldMatrix,
  ceil: () => ceil,
  checker: () => checker,
  clamp: () => clamp,
  code: () => code,
  color: () => color,
  colorSpace: () => colorSpace,
  compute: () => compute,
  cond: () => cond,
  context: () => context,
  convert: () => convert,
  cos: () => cos,
  cross: () => cross,
  cubeTexture: () => cubeTexture,
  dFdx: () => dFdx,
  dFdy: () => dFdy,
  degrees: () => degrees,
  densityFog: () => densityFog,
  difference: () => difference,
  diffuseColor: () => diffuseColor,
  discard: () => discard,
  distance: () => distance,
  div: () => div,
  dodge: () => dodge,
  dot: () => dot,
  dotNV: () => dotNV,
  element: () => element,
  equal: () => equal,
  equirectUV: () => equirectUV,
  exp: () => exp,
  exp2: () => exp2,
  expression: () => expression,
  faceDirection: () => faceDirection,
  faceforward: () => faceforward,
  float: () => float,
  floor: () => floor,
  fn: () => fn,
  fog: () => fog,
  fract: () => fract,
  frameId: () => frameId,
  frontFacing: () => frontFacing,
  func: () => func,
  getDistanceAttenuation: () => getDistanceAttenuation_default,
  getGeometryRoughness: () => getGeometryRoughness_default,
  getRoughness: () => getRoughness_default,
  greaterThan: () => greaterThan,
  greaterThanEqual: () => greaterThanEqual,
  hue: () => hue,
  imat3: () => imat3,
  imat4: () => imat4,
  instance: () => instance,
  instanceIndex: () => instanceIndex,
  int: () => int,
  inversesqrt: () => inversesqrt,
  invert: () => invert,
  ivec2: () => ivec2,
  ivec3: () => ivec3,
  ivec4: () => ivec4,
  label: () => label,
  length: () => length,
  lessThan: () => lessThan,
  lessThanEqual: () => lessThanEqual,
  lightingContext: () => lightingContext,
  lightingModel: () => lightingModel,
  lights: () => lights,
  log: () => log,
  log2: () => log2,
  lumaCoeffs: () => lumaCoeffs,
  luminance: () => luminance,
  mat3: () => mat3,
  mat4: () => mat4,
  matcapUV: () => matcapUV,
  materialAlphaTest: () => materialAlphaTest,
  materialColor: () => materialColor,
  materialEmissive: () => materialEmissive,
  materialMetalness: () => materialMetalness,
  materialNormal: () => materialNormal,
  materialOpacity: () => materialOpacity,
  materialReference: () => materialReference,
  materialReflectivity: () => materialReflectivity,
  materialRotation: () => materialRotation,
  materialRoughness: () => materialRoughness,
  materialShininess: () => materialShininess,
  materialSpecularColor: () => materialSpecularColor,
  materialUV: () => materialUV,
  max: () => max,
  maxMipLevel: () => maxMipLevel,
  metalness: () => metalness,
  min: () => min,
  mix: () => mix,
  mod: () => mod,
  modelDirection: () => modelDirection,
  modelNormalMatrix: () => modelNormalMatrix,
  modelPosition: () => modelPosition,
  modelViewMatrix: () => modelViewMatrix,
  modelViewPosition: () => modelViewPosition,
  modelViewProjection: () => modelViewProjection,
  modelWorldMatrix: () => modelWorldMatrix,
  mul: () => mul,
  negate: () => negate,
  nodeArray: () => nodeArray,
  nodeImmutable: () => nodeImmutable,
  nodeObject: () => nodeObject,
  nodeObjects: () => nodeObjects,
  nodeProxy: () => nodeProxy,
  normalGeometry: () => normalGeometry,
  normalLocal: () => normalLocal,
  normalMap: () => normalMap,
  normalView: () => normalView,
  normalWorld: () => normalWorld,
  normalize: () => normalize,
  objectDirection: () => objectDirection,
  objectNormalMatrix: () => objectNormalMatrix,
  objectPosition: () => objectPosition,
  objectViewMatrix: () => objectViewMatrix,
  objectViewPosition: () => objectViewPosition,
  objectWorldMatrix: () => objectWorldMatrix,
  or: () => or,
  oscSawtooth: () => oscSawtooth,
  oscSine: () => oscSine,
  oscSquare: () => oscSquare,
  oscTriangle: () => oscTriangle,
  overlay: () => overlay,
  phongLightingModel: () => PhongLightingModel_default,
  physicalLightingModel: () => PhysicalLightingModel_default,
  pointUV: () => pointUV,
  positionGeometry: () => positionGeometry,
  positionLocal: () => positionLocal,
  positionView: () => positionView,
  positionViewDirection: () => positionViewDirection,
  positionWorld: () => positionWorld,
  positionWorldDirection: () => positionWorldDirection,
  posterize: () => posterize,
  pow: () => pow,
  pow2: () => pow2,
  pow3: () => pow3,
  pow4: () => pow4,
  property: () => property,
  radians: () => radians,
  range: () => range,
  rangeFog: () => rangeFog,
  reciprocal: () => reciprocal,
  reference: () => reference,
  reflect: () => reflect,
  reflectVector: () => reflectVector,
  refract: () => refract,
  remainder: () => remainder,
  remap: () => remap,
  remapClamp: () => remapClamp,
  rotateUV: () => rotateUV,
  roughness: () => roughness,
  round: () => round,
  sampler: () => sampler,
  saturation: () => saturation,
  screen: () => screen,
  shiftLeft: () => shiftLeft,
  shiftRight: () => shiftRight,
  shininess: () => shininess,
  sign: () => sign,
  sin: () => sin,
  skinning: () => skinning,
  smoothstep: () => smoothstep,
  specularColor: () => specularColor,
  specularMIPLevel: () => specularMIPLevel,
  spritesheetUV: () => spritesheetUV,
  sqrt: () => sqrt,
  step: () => step,
  storage: () => storage,
  sub: () => sub,
  tan: () => tan,
  tangentGeometry: () => tangentGeometry,
  tangentLocal: () => tangentLocal,
  tangentView: () => tangentView,
  tangentWorld: () => tangentWorld,
  temp: () => temp,
  texture: () => texture,
  timerDelta: () => timerDelta,
  timerGlobal: () => timerGlobal,
  timerLocal: () => timerLocal,
  toneMapping: () => toneMapping,
  transformDirection: () => transformDirection,
  transformedBitangentView: () => transformedBitangentView,
  transformedBitangentWorld: () => transformedBitangentWorld,
  transformedNormalView: () => transformedNormalView,
  transformedNormalWorld: () => transformedNormalWorld,
  transformedTangentView: () => transformedTangentView,
  transformedTangentWorld: () => transformedTangentWorld,
  triplanarTexture: () => triplanarTexture,
  triplanarTextures: () => triplanarTextures,
  uint: () => uint,
  umat3: () => umat3,
  umat4: () => umat4,
  uniform: () => uniform,
  userData: () => userData,
  uv: () => uv,
  uvec2: () => uvec2,
  uvec3: () => uvec3,
  uvec4: () => uvec4,
  varying: () => varying,
  vec2: () => vec2,
  vec3: () => vec3,
  vec4: () => vec4,
  vibrance: () => vibrance,
  viewportBottomLeft: () => viewportBottomLeft,
  viewportBottomRight: () => viewportBottomRight,
  viewportCoordinate: () => viewportCoordinate,
  viewportResolution: () => viewportResolution,
  viewportTopLeft: () => viewportTopLeft,
  viewportTopRight: () => viewportTopRight,
  xor: () => xor
});

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.isUVNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var UVNode_default = UVNode;

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var defaultUV;
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, "vec4");
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return defaultUV || (defaultUV = new UVNode_default());
  }
  construct(builder) {
    const properties = builder.getNodeProperties(this);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUVNode) {
      uvNode = builder.context.getUVNode(this);
    }
    uvNode || (uvNode = this.getDefaultUV());
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getSamplerLevelNode) {
      levelNode = builder.context.getSamplerLevelNode(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode(this, levelNode) : null;
  }
  generate(builder, output) {
    const { uvNode, levelNode } = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const uvSnippet = uvNode.build(builder, "vec2");
        const nodeVar = builder.getVarFromNode(this, "vec4");
        propertyName = builder.getPropertyName(nodeVar);
        let snippet = null;
        if (levelNode && levelNode.isNode === true) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet = builder.getTextureLevel(textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
      }
      return builder.format(propertyName, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
var TextureNode_default = TextureNode;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(nodeType, name = null) {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  hasDependencies(builder) {
    return this.op !== "=" ? super.hasDependencies(builder) : false;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a} ${this.op} ${b}`);
        return a;
      } else if (op === "<" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThan")}( ${a}, ${b} )`, type, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output);
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output);
      } else if (op === ">=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThanEqual")}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  op(op, ...params) {
    this.node = new OperatorNode_default(op, this.node, ...params);
    return this;
  }
  assign(...params) {
    return this.op("=", ...params);
  }
  add(...params) {
    return this.op("+", ...params);
  }
  sub(...params) {
    return this.op("-", ...params);
  }
  mul(...params) {
    return this.op("*", ...params);
  }
  div(...params) {
    return this.op("/", ...params);
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const node = this.node;
    const name = this.name;
    if (name === null && node.isTempNode === true) {
      return node.build(builder);
    }
    const type = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, type);
    const nodeVar = builder.getVarFromNode(this, type);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var vectorComponents = "xyzw";
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder, output) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === vectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);
      }
    } else {
      snippet = node.build(builder, output);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var MathNode = class extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new MathNode(MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === MathNode.NEGATE) {
      return builder.format("( -" + a.build(builder, inputType) + " )", type, output);
    } else if (method === MathNode.INVERT) {
      return builder.format("( 1.0 - " + a.build(builder, inputType) + " )", type, output);
    } else if (method === MathNode.RECIPROCAL) {
      return builder.format("( 1.0 / " + a.build(builder, inputType) + " )", type, output);
    } else {
      const params = [];
      if (method === MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (c !== null) {
          params.push(b.build(builder, inputType), c.build(builder, inputType));
        } else if (b !== null) {
          params.push(b.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.INVERT = "invert";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.ATAN2 = "atan2";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var MathNode_default = MathNode;

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var Object3DNode = class extends Node_default {
  constructor(scope = Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.VIEW_MATRIX = "viewMatrix";
Object3DNode.NORMAL_MATRIX = "normalMatrix";
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
var Object3DNode_default = Object3DNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class extends Object3DNode_default {
  constructor(scope = ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var ModelNode_default = ModelNode;

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var CameraNode = class extends Object3DNode_default {
  constructor(scope = CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
CameraNode.PROJECTION_MATRIX = "projectionMatrix";
var CameraNode_default = CameraNode;

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var NormalNode = class extends Node_default {
  constructor(scope = NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope === NormalNode.LOCAL) {
      outputNode = new VaryingNode_default(new NormalNode(NormalNode.GEOMETRY));
    } else if (scope === NormalNode.VIEW) {
      const vertexNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new NormalNode(NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNode));
    } else if (scope === NormalNode.WORLD) {
      const vertexNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new NormalNode(NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
NormalNode.GEOMETRY = "geometry";
NormalNode.LOCAL = "local";
NormalNode.VIEW = "view";
NormalNode.WORLD = "world";
var NormalNode_default = NormalNode;

// node_modules/three/examples/jsm/nodes/accessors/TangentNode.js
var TangentNode = class extends Node_default {
  constructor(scope = TangentNode.LOCAL) {
    super();
    this.scope = scope;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === TangentNode.GEOMETRY) {
      return "vec4";
    }
    return "vec3";
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === TangentNode.GEOMETRY) {
      outputNode = new AttributeNode_default("tangent", "vec4");
    } else if (scope === TangentNode.LOCAL) {
      outputNode = new VaryingNode_default(new SplitNode_default(new TangentNode(TangentNode.GEOMETRY), "xyz"));
    } else if (scope === TangentNode.VIEW) {
      const vertexNode = new SplitNode_default(new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new TangentNode(TangentNode.LOCAL)), "xyz");
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNode));
    } else if (scope === TangentNode.WORLD) {
      const vertexNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new TangentNode(TangentNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
TangentNode.GEOMETRY = "geometry";
TangentNode.LOCAL = "local";
TangentNode.VIEW = "view";
TangentNode.WORLD = "world";
var TangentNode_default = TangentNode;

// node_modules/three/examples/jsm/nodes/accessors/BitangentNode.js
var BitangentNode = class extends Node_default {
  constructor(scope = BitangentNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    const crossNormalTangent = new MathNode_default(MathNode_default.CROSS, new NormalNode_default(scope), new TangentNode_default(scope));
    const tangentW = new SplitNode_default(new TangentNode_default(TangentNode_default.GEOMETRY), "w");
    const vertexNode = new SplitNode_default(new OperatorNode_default("*", crossNormalTangent, tangentW), "xyz");
    const outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNode));
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
BitangentNode.GEOMETRY = "geometry";
BitangentNode.LOCAL = "local";
BitangentNode.VIEW = "view";
BitangentNode.WORLD = "world";
var BitangentNode_default = BitangentNode;

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (const input of nodes) {
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output);
  }
};
var JoinNode_default = JoinNode;

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    let node = null;
    if (uniformType === "texture") {
      node = new TextureNode_default(null);
    } else {
      node = new UniformNode_default(null, uniformType);
    }
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const property2 = this.property;
    this.node.value = object[property2];
  }
  construct() {
    return this.node;
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  construct(builder) {
    const material = this.material !== null ? this.material : builder.material;
    this.node.value = material[this.property];
    return super.construct(builder);
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var MaterialNode = class extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === MaterialNode.OPACITY || scope === MaterialNode.ROTATION) {
      return "float";
    } else if (scope === MaterialNode.UV) {
      return "vec2";
    } else if (scope === MaterialNode.EMISSIVE) {
      return "vec3";
    } else if (scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS || scope === MaterialNode.SPECULAR || scope === MaterialNode.SHININESS) {
      return "float";
    }
  }
  getFloat(property2) {
    return new MaterialReferenceNode_default(property2, "float");
  }
  getColor(property2) {
    return new MaterialReferenceNode_default(property2, "color");
  }
  getTexture(property2) {
    const textureRefNode = new MaterialReferenceNode_default(property2, "texture");
    textureRefNode.node.uvNode = new MaterialNode(MaterialNode.UV);
    return textureRefNode;
  }
  construct(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === MaterialNode.ALPHA_TEST) {
      node = this.getFloat("alphaTest");
    } else if (scope === MaterialNode.COLOR) {
      const colorNode = this.getColor("color");
      if (material.map && material.map.isTexture === true) {
        node = new OperatorNode_default("*", colorNode, this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === MaterialNode.OPACITY) {
      const opacityNode = this.getFloat("opacity");
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = new OperatorNode_default("*", opacityNode, this.getTexture("alphaMap"));
      } else {
        node = opacityNode;
      }
    } else if (scope === MaterialNode.SHININESS) {
      node = this.getFloat("shininess");
    } else if (scope === MaterialNode.SPECULAR_COLOR) {
      node = this.getColor("specular");
    } else if (scope === MaterialNode.REFLECTIVITY) {
      const reflectivityNode = this.getFloat("reflectivity");
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = new OperatorNode_default("*", reflectivityNode, new SplitNode_default(this.getTexture("specularMap"), "r"));
      } else {
        node = reflectivityNode;
      }
    } else if (scope === MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat("roughness");
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = new OperatorNode_default("*", roughnessNode, new SplitNode_default(this.getTexture("roughnessMap"), "g"));
      } else {
        node = roughnessNode;
      }
    } else if (scope === MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat("metalness");
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = new OperatorNode_default("*", metalnessNode, new SplitNode_default(this.getTexture("metalnessMap"), "b"));
      } else {
        node = metalnessNode;
      }
    } else if (scope === MaterialNode.EMISSIVE) {
      const emissiveNode = this.getColor("emissive");
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = new OperatorNode_default("*", emissiveNode, this.getTexture("emissiveMap"));
      } else {
        node = emissiveNode;
      }
    } else if (scope === MaterialNode.ROTATION) {
      node = this.getFloat("rotation");
    } else if (scope === MaterialNode.UV) {
      let uvNode;
      let uvScaleMap = material.map || material.specularMap || material.displacementMap || material.normalMap || material.bumpMap || material.roughnessMap || material.metalnessMap || material.alphaMap || material.emissiveMap || material.clearcoatMap || material.clearcoatNormalMap || material.clearcoatRoughnessMap || material.iridescenceMap || material.iridescenceThicknessMap || material.specularIntensityMap || material.specularColorMap || material.transmissionMap || material.thicknessMap || material.sheenColorMap || material.sheenRoughnessMap;
      if (uvScaleMap) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uvNode = new OperatorNode_default("*", new UniformNode_default(uvScaleMap.matrix), new JoinNode_default([new UVNode_default(), new ConstNode_default(1)]));
      }
      return uvNode || new UVNode_default();
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.UV = "uv";
var MaterialNode_default = MaterialNode;

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var PositionNode = class extends Node_default {
  constructor(scope = PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope === PositionNode.LOCAL) {
      outputNode = new VaryingNode_default(new PositionNode(PositionNode.GEOMETRY));
    } else if (scope === PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryingNode_default(vertexPositionNode);
    } else if (scope === PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryingNode_default(vertexPositionNode);
    } else if (scope === PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new PositionNode(PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexPositionNode));
    } else if (scope === PositionNode.WORLD_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new PositionNode(PositionNode.WORLD));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
PositionNode.GEOMETRY = "geometry";
PositionNode.LOCAL = "local";
PositionNode.WORLD = "world";
PositionNode.WORLD_DIRECTION = "worldDirection";
PositionNode.VIEW = "view";
PositionNode.VIEW_DIRECTION = "viewDirection";
var PositionNode_default = PositionNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(position = new PositionNode_default()) {
    super("vec4");
    this.position = position;
  }
  generate(builder) {
    const position = this.position;
    const mvpMatrix = new OperatorNode_default("*", new CameraNode_default(CameraNode_default.PROJECTION_MATRIX), new ModelNode_default(ModelNode_default.VIEW_MATRIX));
    const mvpNode = new OperatorNode_default("*", mvpMatrix, position);
    return mvpNode.build(builder);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var PointUVNode_default = PointUVNode;

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
  }
  getInputType() {
    return "storageBuffer";
  }
};
var StorageBufferNode_default = StorageBufferNode;

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.object = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
var UserDataNode_default = UserDataNode;

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
var FrontFacingNode_default = FrontFacingNode;

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateDispatchCount();
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  update({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addFlowCode(snippet);
      }
    }
  }
};
var ComputeNode_default = ComputeNode;

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const needsProperty = this.ifNode.getNodeType(builder) !== "void" || this.elseNode && this.elseNode.getNodeType(builder) !== "void";
    const nodeProperty = needsProperty ? new PropertyNode_default(type).build(builder) : "";
    const nodeSnippet = new ContextNode_default(
      this.condNode
      /*, context*/
    ).build(builder, "bool");
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		`, false);
    let ifSnippet = new ContextNode_default(this.ifNode, context2).build(builder, type);
    ifSnippet = needsProperty ? nodeProperty + " = " + ifSnippet + ";" : ifSnippet;
    builder.addFlowCode(ifSnippet + "\n\n	}", false);
    let elseSnippet = this.elseNode ? new ContextNode_default(this.elseNode, context2).build(builder, type) : null;
    if (elseSnippet) {
      elseSnippet = nodeProperty ? nodeProperty + " = " + elseSnippet + ";" : elseSnippet;
      builder.addFlowCode("else {\n\n		" + elseSnippet + "\n\n	}", false);
    }
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  generate(builder, output) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output);
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/three/examples/jsm/nodes/utils/DiscardNode.js
var discardExpression;
var DiscardNode = class extends CondNode_default {
  constructor(condNode) {
    discardExpression = discardExpression || new ExpressionNode_default("discard");
    super(condNode, discardExpression);
  }
};
var DiscardNode_default = DiscardNode;

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(textureNode) {
    super(0);
    this.textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;

// node_modules/three/examples/jsm/nodes/core/StackNode.js
var StackNode = class extends Node_default {
  constructor() {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  add(node) {
    this.nodes.push(new BypassNode_default(new ExpressionNode_default(), node));
    return this;
  }
  assign(targetNode, sourceValue) {
    return this.add(new OperatorNode_default("=", targetNode, sourceValue));
  }
  build(builder, ...params) {
    for (const node of this.nodes) {
      node.build(builder);
    }
    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
  }
};
var StackNode_default = StackNode;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var shaderNodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get: function(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(node, new ConstNode_default(Number(prop), "uint")));
      } else if (ShaderNodeElements_exports[prop]) {
        const nodeElement = ShaderNodeElements_exports[prop];
        return (...params) => nodeElement(nodeObj, ...params);
      }
    }
    return node[prop];
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type = typeof obj;
  if (type === "number" || type === "boolean") {
    return nodeObject(getAutoTypedConstNode(obj));
  } else if (type === "object") {
    if (obj && obj.isNode === true) {
      let nodeObject2 = nodeObjectsCacheMap.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, shaderNodeHandler);
        nodeObjectsCacheMap.set(obj, nodeObject2);
        nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name]);
  }
  return objects;
};
var ShaderNodeArray = function(array) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderNodeInternal = class extends Node_default {
  constructor(jsFunc) {
    super();
    this._jsFunc = jsFunc;
  }
  call(inputs, builder) {
    inputs = nodeObjects(inputs);
    return nodeObject(this._jsFunc(inputs, builder));
  }
  getNodeType(builder) {
    const { outputNode } = builder.getNodeProperties(this);
    return outputNode ? outputNode.getNodeType(builder) : super.getNodeType(builder);
  }
  construct(builder) {
    const stackNode = new StackNode_default();
    stackNode.outputNode = this.call({}, stackNode, builder);
    return stackNode;
  }
};
var ShaderNodeScript = function(jsFunc) {
  return new ShaderNodeInternal(jsFunc);
};
var ShaderNode = new Proxy(ShaderNodeScript, shaderNodeHandler);
var nodeObject = (val) => (
  /* new */
  ShaderNodeObject(val)
);
var nodeObjects = (val) => new ShaderNodeObjects(val);
var nodeArray = (val) => new ShaderNodeArray(val);
var nodeProxy = (...val) => new ShaderNodeProxy(...val);
var nodeImmutable = (...val) => new ShaderNodeImmutable(...val);
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type), type));
    } else {
      if (type === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      if (nodes.length === 1) {
        return nodeObject(nodes[0].nodeType === type ? nodes[0] : new ConvertNode_default(nodes[0], type));
      }
      return nodeObject(new JoinNode_default(nodes, type));
    }
  };
};
var getConstNodeType = (value) => value.nodeType || value.convertTo || (typeof value === "string" ? value : null);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var func = (code2, includes3) => {
  const node = nodeObject(new FunctionNode_default(code2, includes3));
  const call2 = node.call.bind(node);
  node.call = (...params) => nodeObject(call2(params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0])));
  return node;
};
var uniform = (nodeOrType) => {
  const nodeType = getConstNodeType(nodeOrType);
  const value = nodeOrType.isNode === true ? nodeOrType.node && nodeOrType.node.value || nodeOrType.value : nodeOrType;
  return nodeObject(new UniformNode_default(value, nodeType));
};
var fn = (code2, includes3) => func(code2, includes3).call;
var attribute = (name, nodeType) => nodeObject(new AttributeNode_default(name, nodeType));
var property = (name, nodeOrType) => nodeObject(new PropertyNode_default(name, getConstNodeType(nodeOrType)));
var convert = (node, types) => nodeObject(new ConvertNode_default(nodeObject(node), types));
var maxMipLevel = nodeProxy(MaxMipLevelNode_default);
var bypass = nodeProxy(BypassNode_default);
var cache = nodeProxy(CacheNode_default);
var code = nodeProxy(CodeNode_default);
var context = nodeProxy(ContextNode_default);
var expression = nodeProxy(ExpressionNode_default);
var call = nodeProxy(FunctionCallNode_default);
var instanceIndex = nodeImmutable(InstanceIndexNode_default);
var label = nodeProxy(VarNode_default);
var temp = label;
var varying = nodeProxy(VaryingNode_default);
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var cond = nodeProxy(CondNode_default);
var add = nodeProxy(OperatorNode_default, "+");
var sub = nodeProxy(OperatorNode_default, "-");
var mul = nodeProxy(OperatorNode_default, "*");
var div = nodeProxy(OperatorNode_default, "/");
var remainder = nodeProxy(OperatorNode_default, "%");
var equal = nodeProxy(OperatorNode_default, "==");
var assign = nodeProxy(OperatorNode_default, "=");
var lessThan = nodeProxy(OperatorNode_default, "<");
var greaterThan = nodeProxy(OperatorNode_default, ">");
var lessThanEqual = nodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = nodeProxy(OperatorNode_default, ">=");
var and = nodeProxy(OperatorNode_default, "&&");
var or = nodeProxy(OperatorNode_default, "||");
var xor = nodeProxy(OperatorNode_default, "^^");
var bitAnd = nodeProxy(OperatorNode_default, "&");
var bitOr = nodeProxy(OperatorNode_default, "|");
var bitXor = nodeProxy(OperatorNode_default, "^");
var shiftLeft = nodeProxy(OperatorNode_default, "<<");
var shiftRight = nodeProxy(OperatorNode_default, ">>");
var radians = nodeProxy(MathNode_default, MathNode_default.RADIANS);
var degrees = nodeProxy(MathNode_default, MathNode_default.DEGREES);
var exp = nodeProxy(MathNode_default, MathNode_default.EXP);
var exp2 = nodeProxy(MathNode_default, MathNode_default.EXP2);
var log = nodeProxy(MathNode_default, MathNode_default.LOG);
var log2 = nodeProxy(MathNode_default, MathNode_default.LOG2);
var sqrt = nodeProxy(MathNode_default, MathNode_default.SQRT);
var inversesqrt = nodeProxy(MathNode_default, MathNode_default.INVERSE_SQRT);
var floor = nodeProxy(MathNode_default, MathNode_default.FLOOR);
var ceil = nodeProxy(MathNode_default, MathNode_default.CEIL);
var normalize = nodeProxy(MathNode_default, MathNode_default.NORMALIZE);
var fract = nodeProxy(MathNode_default, MathNode_default.FRACT);
var sin = nodeProxy(MathNode_default, MathNode_default.SIN);
var cos = nodeProxy(MathNode_default, MathNode_default.COS);
var tan = nodeProxy(MathNode_default, MathNode_default.TAN);
var asin = nodeProxy(MathNode_default, MathNode_default.ASIN);
var acos = nodeProxy(MathNode_default, MathNode_default.ACOS);
var atan = nodeProxy(MathNode_default, MathNode_default.ATAN);
var abs = nodeProxy(MathNode_default, MathNode_default.ABS);
var sign = nodeProxy(MathNode_default, MathNode_default.SIGN);
var length = nodeProxy(MathNode_default, MathNode_default.LENGTH);
var negate = nodeProxy(MathNode_default, MathNode_default.NEGATE);
var invert = nodeProxy(MathNode_default, MathNode_default.INVERT);
var dFdx = nodeProxy(MathNode_default, MathNode_default.DFDX);
var dFdy = nodeProxy(MathNode_default, MathNode_default.DFDY);
var round = nodeProxy(MathNode_default, MathNode_default.ROUND);
var reciprocal = nodeProxy(MathNode_default, MathNode_default.RECIPROCAL);
var atan2 = nodeProxy(MathNode_default, MathNode_default.ATAN2);
var min = nodeProxy(MathNode_default, MathNode_default.MIN);
var max = nodeProxy(MathNode_default, MathNode_default.MAX);
var mod = nodeProxy(MathNode_default, MathNode_default.MOD);
var step = nodeProxy(MathNode_default, MathNode_default.STEP);
var reflect = nodeProxy(MathNode_default, MathNode_default.REFLECT);
var distance = nodeProxy(MathNode_default, MathNode_default.DISTANCE);
var dot = nodeProxy(MathNode_default, MathNode_default.DOT);
var cross = nodeProxy(MathNode_default, MathNode_default.CROSS);
var pow = nodeProxy(MathNode_default, MathNode_default.POW);
var pow2 = nodeProxy(MathNode_default, MathNode_default.POW, 2);
var pow3 = nodeProxy(MathNode_default, MathNode_default.POW, 3);
var pow4 = nodeProxy(MathNode_default, MathNode_default.POW, 4);
var transformDirection = nodeProxy(MathNode_default, MathNode_default.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode_default, MathNode_default.MIX);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode_default(MathNode_default.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var refract = nodeProxy(MathNode_default, MathNode_default.REFRACT);
var smoothstep = nodeProxy(MathNode_default, MathNode_default.SMOOTHSTEP);
var faceforward = nodeProxy(MathNode_default, MathNode_default.FACEFORWARD);
var buffer = (value, nodeOrType, count) => nodeObject(new BufferNode_default(value, getConstNodeType(nodeOrType), count));
var storage = (value, nodeOrType, count) => nodeObject(new StorageBufferNode_default(value, getConstNodeType(nodeOrType), count));
var cameraProjectionMatrix = nodeImmutable(CameraNode_default, CameraNode_default.PROJECTION_MATRIX);
var cameraViewMatrix = nodeImmutable(CameraNode_default, CameraNode_default.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode_default, CameraNode_default.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode_default, CameraNode_default.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode_default, CameraNode_default.POSITION);
var materialUV = nodeImmutable(MaterialNode_default, MaterialNode_default.UV);
var materialAlphaTest = nodeImmutable(MaterialNode_default, MaterialNode_default.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode_default, MaterialNode_default.COLOR);
var materialShininess = nodeImmutable(MaterialNode_default, MaterialNode_default.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode_default, MaterialNode_default.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode_default, MaterialNode_default.OPACITY);
var materialSpecularColor = nodeImmutable(MaterialNode_default, MaterialNode_default.SPECULAR_COLOR);
var materialReflectivity = nodeImmutable(MaterialNode_default, MaterialNode_default.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode_default, MaterialNode_default.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode_default, MaterialNode_default.METALNESS);
var materialRotation = nodeImmutable(MaterialNode_default, MaterialNode_default.ROTATION);
var diffuseColor = nodeImmutable(PropertyNode_default, "vec4", "DiffuseColor");
var roughness = nodeImmutable(PropertyNode_default, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode_default, "float", "Metalness");
var specularColor = nodeImmutable(PropertyNode_default, "color", "SpecularColor");
var shininess = nodeImmutable(PropertyNode_default, "float", "Shininess");
var reference = (name, nodeOrType, object) => nodeObject(new ReferenceNode_default(name, getConstNodeType(nodeOrType), object));
var materialReference = (name, nodeOrType, material) => nodeObject(new MaterialReferenceNode_default(name, getConstNodeType(nodeOrType), material));
var userData = (name, inputType, userData2) => nodeObject(new UserDataNode_default(name, inputType, userData2));
var modelViewProjection = nodeProxy(ModelViewProjectionNode_default);
var normalGeometry = nodeImmutable(NormalNode_default, NormalNode_default.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode_default, NormalNode_default.LOCAL);
var normalView = nodeImmutable(NormalNode_default, NormalNode_default.VIEW);
var normalWorld = nodeImmutable(NormalNode_default, NormalNode_default.WORLD);
var transformedNormalView = nodeImmutable(VarNode_default, normalView, "TransformedNormalView");
var transformedNormalWorld = normalize(transformDirection(transformedNormalView, cameraViewMatrix));
var tangentGeometry = nodeImmutable(TangentNode_default, TangentNode_default.GEOMETRY);
var tangentLocal = nodeImmutable(TangentNode_default, TangentNode_default.LOCAL);
var tangentView = nodeImmutable(TangentNode_default, TangentNode_default.VIEW);
var tangentWorld = nodeImmutable(TangentNode_default, TangentNode_default.WORLD);
var transformedTangentView = nodeImmutable(VarNode_default, tangentView, "TransformedTangentView");
var transformedTangentWorld = normalize(transformDirection(transformedTangentView, cameraViewMatrix));
var bitangentGeometry = nodeImmutable(BitangentNode_default, BitangentNode_default.GEOMETRY);
var bitangentLocal = nodeImmutable(BitangentNode_default, BitangentNode_default.LOCAL);
var bitangentView = nodeImmutable(BitangentNode_default, BitangentNode_default.VIEW);
var bitangentWorld = nodeImmutable(BitangentNode_default, BitangentNode_default.WORLD);
var transformedBitangentView = normalize(mul(cross(transformedNormalView, transformedTangentView), tangentGeometry.w));
var transformedBitangentWorld = normalize(transformDirection(transformedBitangentView, cameraViewMatrix));
var modelDirection = nodeImmutable(ModelNode_default, ModelNode_default.DIRECTION);
var modelViewMatrix = nodeImmutable(ModelNode_default, ModelNode_default.VIEW_MATRIX);
var modelNormalMatrix = nodeImmutable(ModelNode_default, ModelNode_default.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode_default, ModelNode_default.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode_default, ModelNode_default.POSITION);
var modelViewPosition = nodeImmutable(ModelNode_default, ModelNode_default.VIEW_POSITION);
var objectDirection = nodeProxy(Object3DNode_default, Object3DNode_default.DIRECTION);
var objectViewMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.VIEW_MATRIX);
var objectNormalMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.NORMAL_MATRIX);
var objectWorldMatrix = nodeProxy(Object3DNode_default, Object3DNode_default.WORLD_MATRIX);
var objectPosition = nodeProxy(Object3DNode_default, Object3DNode_default.POSITION);
var objectViewPosition = nodeProxy(Object3DNode_default, Object3DNode_default.VIEW_POSITION);
var positionGeometry = nodeImmutable(PositionNode_default, PositionNode_default.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode_default, PositionNode_default.LOCAL);
var positionWorld = nodeImmutable(PositionNode_default, PositionNode_default.WORLD);
var positionWorldDirection = nodeImmutable(PositionNode_default, PositionNode_default.WORLD_DIRECTION);
var positionView = nodeImmutable(PositionNode_default, PositionNode_default.VIEW);
var positionViewDirection = nodeImmutable(PositionNode_default, PositionNode_default.VIEW_DIRECTION);
var texture = nodeProxy(TextureNode_default);
var sampler = (texture2) => nodeObject(new ConvertNode_default(texture2.isNode === true ? texture2 : new TextureNode_default(texture2), "sampler"));
var uv = (...params) => nodeObject(new UVNode_default(...params));
var pointUV = nodeImmutable(PointUVNode_default);
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode_default(nodeObject(node), count, workgroupSize));
var frontFacing = nodeImmutable(FrontFacingNode_default);
var faceDirection = sub(mul(float(frontFacing), 2), 1);
var lightingModel = (...params) => new LightingModel_default(...params);
var element = nodeProxy(ArrayElementNode_default);
var discard = nodeProxy(DiscardNode_default);
var lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);
var luminance = (color2, luma = lumaCoeffs) => dot(color2, luma);
var difference = (a, b) => abs(sub(a, b));
var dotNV = clamp(dot(transformedNormalView, positionViewDirection));
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView);

// node_modules/three/examples/jsm/nodes/accessors/ReflectVectorNode.js
var ReflectVectorNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  construct() {
    const reflectView = positionViewDirection.negate().reflect(transformedNormalView);
    return reflectView.transformDirection(cameraViewMatrix);
  }
};
var ReflectVectorNode_default = ReflectVectorNode;

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var defaultUV2;
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return defaultUV2 || (defaultUV2 = new ReflectVectorNode_default());
  }
  generate(builder, output) {
    const { uvNode, levelNode } = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const uvNodeObject = nodeObject(uvNode);
        const cubeUV = vec3(uvNodeObject.x.negate(), uvNodeObject.yz);
        const uvSnippet = cubeUV.build(builder, "vec3");
        const nodeVar = builder.getVarFromNode(this, "vec4");
        propertyName = builder.getPropertyName(nodeVar);
        let snippet = null;
        if (levelNode && levelNode.isNode === true) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet = builder.getCubeTextureLevel(textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet = builder.getCubeTexture(textureProperty, uvSnippet);
        }
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
      }
      return builder.format(propertyName, "vec4", output);
    }
  }
};
var CubeTextureNode_default = CubeTextureNode;

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    const instanceBufferNode = buffer(instanceMesh.instanceMatrix.array, "mat4", instanceMesh.count);
    this.instanceMatrixNode = temp(element(instanceBufferNode, instanceIndex));
  }
  generate(builder) {
    const { instanceMatrixNode } = this;
    const instancePosition = mul(instanceMatrixNode, positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = div(normalLocal, vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2])));
    const instanceNormal = mul(m, transformedNormal).xyz;
    assign(positionLocal, instancePosition).build(builder);
    assign(normalLocal, instanceNormal).build(builder);
  }
};
var InstanceNode_default = InstanceNode;

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, builder) => {
  const { index, weight, bindMatrix, bindMatrixInverse, boneMatrices } = inputs;
  const boneMatX = element(boneMatrices, index.x);
  const boneMatY = element(boneMatrices, index.y);
  const boneMatZ = element(boneMatrices, index.z);
  const boneMatW = element(boneMatrices, index.w);
  const skinVertex = mul(bindMatrix, positionLocal);
  const skinned = add(
    mul(mul(boneMatX, skinVertex), weight.x),
    mul(mul(boneMatY, skinVertex), weight.y),
    mul(mul(boneMatZ, skinVertex), weight.z),
    mul(mul(boneMatW, skinVertex), weight.w)
  );
  const skinPosition = mul(bindMatrixInverse, skinned).xyz;
  let skinMatrix = add(
    mul(weight.x, boneMatX),
    mul(weight.y, boneMatY),
    mul(weight.z, boneMatZ),
    mul(weight.w, boneMatW)
  );
  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);
  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz;
  assign(positionLocal, skinPosition).build(builder);
  assign(normalLocal, skinNormal).build(builder);
  if (builder.hasGeometryAttribute("tangent")) {
    assign(tangentLocal, skinNormal).build(builder);
  }
});
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(mat4(skinnedMesh.bindMatrix));
    this.bindMatrixInverseNode = uniform(mat4(skinnedMesh.bindMatrixInverse));
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  generate(builder) {
    Skinning.call({
      index: this.skinIndexNode,
      weight: this.skinWeightNode,
      bindMatrix: this.bindMatrixNode,
      bindMatrixInverse: this.bindMatrixInverseNode,
      boneMatrices: this.boneMatricesNode
    }, builder);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = dFdx(eye_pos.xyz);
  const q1 = dFdy(eye_pos.xyz);
  const st0 = dFdx(uv2.st);
  const st1 = dFdy(uv2.st);
  const N = surf_norm;
  const q1perp = cross(q1, N);
  const q0perp = cross(N, q0);
  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));
  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));
  const det = max(dot(T, T), dot(B, B));
  const scale = mul(faceDirection, inversesqrt(det));
  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  construct(builder) {
    const { normalMapType, scaleNode } = this;
    const normalOP = mul(this.node, 2);
    let normalMap2 = sub(normalOP, 1);
    if (scaleNode !== null) {
      const normalMapScale = mul(normalMap2.xy, scaleNode);
      normalMap2 = vec3(normalMapScale, normalMap2.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      outputNode = normalize(mul(modelNormalMatrix, normalMap2));
    } else if (normalMapType === TangentSpaceNormalMap) {
      const tangent = builder.hasGeometryAttribute("tangent");
      if (tangent === true) {
        outputNode = normalize(mul(TBNViewMatrix, normalMap2));
      } else {
        outputNode = perturbNormal2ArbNode.call({
          eye_pos: positionView,
          surf_norm: normalView,
          mapN: normalMap2,
          uv: uv()
        });
      }
    }
    return outputNode;
  }
};
var NormalMapNode_default = NormalMapNode;

// node_modules/three/examples/jsm/nodes/accessors/ExtendedMaterialNode.js
var ExtendedMaterialNode = class extends MaterialNode_default {
  constructor(scope) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    let type = null;
    if (scope === ExtendedMaterialNode.NORMAL) {
      type = "vec3";
    }
    return type || super.getNodeType(builder);
  }
  construct(builder) {
    const material = builder.material;
    const scope = this.scope;
    let node = null;
    if (scope === ExtendedMaterialNode.NORMAL) {
      node = material.normalMap ? new NormalMapNode_default(this.getTexture("normalMap"), materialReference("normalScale", "vec2")) : normalView;
    }
    return node || super.construct(builder);
  }
};
ExtendedMaterialNode.NORMAL = "normal";
var ExtendedMaterialNode_default = ExtendedMaterialNode;

// node_modules/three/examples/jsm/nodes/display/BlendModeNode.js
var BurnNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => cond(lessThan(blend[c], EPSILON), blend[c], max(sub(1, div(sub(1, base[c]), blend[c])), 0));
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var DodgeNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => cond(equal(blend[c], 1), blend[c], max(div(base[c], sub(1, blend[c])), 0));
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var ScreenNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => sub(1, mul(sub(1, base[c]), sub(1, blend[c])));
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var OverlayNode = new ShaderNode(({ base, blend }) => {
  const fn2 = (c) => cond(lessThan(base[c], 0.5), mul(2, base[c], blend[c]), sub(1, mul(sub(1, base[c]), sub(1, blend[c]))));
  return vec3(fn2("x"), fn2("y"), fn2("z"));
});
var BlendModeNode = class extends Node_default {
  constructor(blendMode, baseNode, blendNode) {
    super();
    this.blendMode = blendMode;
    this.baseNode = baseNode;
    this.blendNode = blendNode;
  }
  construct() {
    const { blendMode, baseNode, blendNode } = this;
    const params = { base: baseNode, blend: blendNode };
    let outputNode = null;
    if (blendMode === BlendModeNode.BURN) {
      outputNode = BurnNode.call(params);
    } else if (blendMode === BlendModeNode.DODGE) {
      outputNode = DodgeNode.call(params);
    } else if (blendMode === BlendModeNode.SCREEN) {
      outputNode = ScreenNode.call(params);
    } else if (blendMode === BlendModeNode.OVERLAY) {
      outputNode = OverlayNode.call(params);
    }
    return outputNode;
  }
};
BlendModeNode.BURN = "burn";
BlendModeNode.DODGE = "dodge";
BlendModeNode.SCREEN = "screen";
BlendModeNode.OVERLAY = "overlay";
var BlendModeNode_default = BlendModeNode;

// node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js
var saturationNode = new ShaderNode(({ color: color2, adjustment }) => {
  return mix(luminance(color2), color2, adjustment);
});
var vibranceNode = new ShaderNode(({ color: color2, adjustment }) => {
  const average = div(add(color2.r, color2.g, color2.b), 3);
  const mx = max(color2.r, max(color2.g, color2.b));
  const amt = mul(sub(mx, average), mul(-3, adjustment));
  return mix(color2.rgb, vec3(mx), amt);
});
var hueNode = new ShaderNode(({ color: color2, adjustment }) => {
  const RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
  const YIQtoRGB = mat3(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046);
  const yiq = mul(RGBtoYIQ, color2);
  const hue2 = add(atan2(yiq.z, yiq.y), adjustment);
  const chroma = sqrt(add(mul(yiq.z, yiq.z), mul(yiq.y, yiq.y)));
  return mul(YIQtoRGB, vec3(yiq.x, mul(chroma, cos(hue2)), mul(chroma, sin(hue2))));
});
var ColorAdjustmentNode = class extends TempNode_default {
  constructor(method, colorNode, adjustmentNode = float(1)) {
    super("vec3");
    this.method = method;
    this.colorNode = colorNode;
    this.adjustmentNode = adjustmentNode;
  }
  construct() {
    const { method, colorNode, adjustmentNode } = this;
    const callParams = { color: colorNode, adjustment: adjustmentNode };
    let outputNode = null;
    if (method === ColorAdjustmentNode.SATURATION) {
      outputNode = saturationNode.call(callParams);
    } else if (method === ColorAdjustmentNode.VIBRANCE) {
      outputNode = vibranceNode.call(callParams);
    } else if (method === ColorAdjustmentNode.HUE) {
      outputNode = hueNode.call(callParams);
    } else {
      console.error(`${this.type}: Method "${this.method}" not supported!`);
    }
    return outputNode;
  }
};
ColorAdjustmentNode.SATURATION = "saturation";
ColorAdjustmentNode.VIBRANCE = "vibrance";
ColorAdjustmentNode.HUE = "hue";
var ColorAdjustmentNode_default = ColorAdjustmentNode;

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const { value } = inputs;
  const rgb = value.rgb;
  const a = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));
  const b = mul(rgb, 12.92);
  const factor = vec3(lessThanEqual(rgb, vec3(31308e-7)));
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var ColorSpaceNode = class extends Node_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  construct() {
    const method = this.method;
    const node = this.node;
    let outputNode = null;
    if (method !== ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      outputNode = encodingFunctionNode.call({
        value: node
      });
    } else {
      outputNode = node;
    }
    return outputNode;
  }
};
ColorSpaceNode.LINEAR_TO_LINEAR = "LinearToLinear";
ColorSpaceNode.LINEAR_TO_SRGB = "LinearTosRGB";
var ColorSpaceNode_default = ColorSpaceNode;

// node_modules/three/examples/jsm/nodes/display/PosterizeNode.js
var PosterizeNode = class extends Node_default {
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  construct() {
    const { sourceNode, stepsNode } = this;
    return mul(floor(mul(sourceNode, stepsNode)), reciprocal(stepsNode));
  }
};
var PosterizeNode_default = PosterizeNode;

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  return color2.mul(exposure);
});
var ReinhardToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  return clamp(color2.div(vec3(1).add(color2)));
});
var OptimizedCineonToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  color2 = max(vec3(0), color2.sub(4e-3));
  const a = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return pow(a.div(b), vec3(2.2));
});
var RRTAndODTFit = new ShaderNode(({ color: color2 }) => {
  const a = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var ACESFilmicToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  const ACESInputMat = mat3(
    vec3(0.59719, 0.076, 0.0284),
    // transposed from source
    vec3(0.35458, 0.90834, 0.13383),
    vec3(0.04823, 0.01566, 0.83777)
  );
  const ACESOutputMat = mat3(
    vec3(1.60475, -0.10208, -327e-5),
    // transposed from source
    vec3(-0.53108, 1.10813, -0.07276),
    vec3(-0.07367, -605e-5, 1.07602)
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit.call({ color: color2 });
  color2 = ACESOutputMat.mul(color2);
  return clamp(color2);
});
var toneMappingLib = {
  [LinearToneMapping]: LinearToneMappingNode,
  [ReinhardToneMapping]: ReinhardToneMappingNode,
  [CineonToneMapping]: OptimizedCineonToneMappingNode,
  [ACESFilmicToneMapping]: ACESFilmicToneMappingNode
};
var ToneMappingNode = class extends Node_default {
  constructor(toneMapping2 = NoToneMapping, exposureNode = float(1), colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  construct(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping)
      return colorNode;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    const toneMappingNode = toneMappingLib[toneMapping2];
    let outputNode = null;
    if (toneMappingNode) {
      outputNode = toneMappingNode.call(toneMappingParams);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var ToneMappingNode_default = ToneMappingNode;

// node_modules/three/examples/jsm/nodes/display/ViewportNode.js
var resolution;
var ViewportNode = class extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  getNodeType() {
    return this.scope === ViewportNode.COORDINATE ? "vec4" : "vec2";
  }
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === ViewportNode.RESOLUTION) {
      updateType = NodeUpdateType.FRAME;
    }
    this.updateType = updateType;
    return updateType;
  }
  update({ renderer }) {
    renderer.getSize(resolution);
  }
  construct(builder) {
    const scope = this.scope;
    if (scope === ViewportNode.COORDINATE)
      return;
    let output = null;
    if (scope === ViewportNode.RESOLUTION) {
      output = uniform(resolution || (resolution = new Vector2()));
    } else {
      const coordinateNode = vec2(new ViewportNode(ViewportNode.COORDINATE));
      const resolutionNode = new ViewportNode(ViewportNode.RESOLUTION);
      output = div(coordinateNode, resolutionNode);
      let outX = output.x;
      let outY = output.y;
      if (/top/i.test(scope) && builder.isFlipY())
        outY = invert(outY);
      else if (/bottom/i.test(scope) && builder.isFlipY() === false)
        outY = invert(outY);
      if (/right/i.test(scope))
        outX = invert(outX);
      output = vec2(outX, outY);
    }
    return output;
  }
  generate(builder) {
    if (this.scope === ViewportNode.COORDINATE) {
      return builder.getFragCoord();
    }
    return super.generate(builder);
  }
};
ViewportNode.COORDINATE = "coordinate";
ViewportNode.RESOLUTION = "resolution";
ViewportNode.TOP_LEFT = "topLeft";
ViewportNode.BOTTOM_LEFT = "bottomLeft";
ViewportNode.TOP_RIGHT = "topRight";
ViewportNode.BOTTOM_RIGHT = "bottomRight";
var ViewportNode_default = ViewportNode;

// node_modules/three/examples/jsm/nodes/lighting/LightingNode.js
var LightingNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var LightingNode_default = LightingNode;

// node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js
var AnalyticLightNode = class extends LightingNode_default {
  constructor(light = null) {
    super();
    this.updateType = NodeUpdateType.OBJECT;
    this.light = light;
    this.colorNode = uniform(new Color());
  }
  getHash() {
    return this.light.uuid;
  }
  update() {
    const { light } = this;
    this.colorNode.value.copy(light.color).multiplyScalar(light.intensity);
  }
};
var AnalyticLightNode_default = AnalyticLightNode;

// node_modules/three/examples/jsm/nodes/lighting/LightsNode.js
var references = /* @__PURE__ */ new WeakMap();
var sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  construct(builder) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getHash(builder) {
    if (this._hash === null) {
      let hash = "";
      const lightNodes = this.lightNodes;
      for (const lightNode of lightNodes) {
        hash += lightNode.getHash(builder) + " ";
      }
      this._hash = hash;
    }
    return this._hash;
  }
  getLightNodeByHash(hash) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      if (lightNode.light.uuid === hash) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights2) {
    const lightNodes = [];
    lights2 = sortLights(lights2);
    for (const light of lights2) {
      let lightNode = this.getLightNodeByHash(light.uuid);
      if (lightNode === null) {
        const lightClass = light.constructor;
        const lightNodeClass = references.has(lightClass) ? references.get(lightClass) : AnalyticLightNode_default;
        lightNode = new lightNodeClass(light);
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
  static setReference(lightClass, lightNodeClass) {
    references.set(lightClass, lightNodeClass);
  }
};
var LightsNode_default = LightsNode;

// node_modules/three/examples/jsm/nodes/lighting/LightingContextNode.js
var LightingContextNode = class extends ContextNode_default {
  constructor(node, lightingModelNode = null) {
    super(node);
    this.lightingModelNode = lightingModelNode;
  }
  getNodeType() {
    return "vec3";
  }
  construct(builder) {
    const { lightingModelNode } = this;
    const context2 = this.context = {};
    const properties = builder.getNodeProperties(this);
    const directDiffuse = temp(vec3()), directSpecular = temp(vec3()), indirectDiffuse = temp(vec3()), indirectSpecular = temp(vec3()), total = add(directDiffuse, directSpecular, indirectDiffuse, indirectSpecular);
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular,
      total
    };
    const lighting = {
      radiance: temp(vec3()),
      irradiance: temp(vec3()),
      iblIrradiance: temp(vec3()),
      ambientOcclusion: temp(float(1))
    };
    Object.assign(properties, reflectedLight, lighting);
    Object.assign(context2, lighting);
    context2.reflectedLight = reflectedLight;
    context2.lightingModelNode = lightingModelNode || context2.lightingModelNode;
    if (lightingModelNode && lightingModelNode.indirectDiffuse)
      lightingModelNode.indirectDiffuse.call(context2);
    if (lightingModelNode && lightingModelNode.indirectSpecular)
      lightingModelNode.indirectSpecular.call(context2);
    if (lightingModelNode && lightingModelNode.ambientOcclusion)
      lightingModelNode.ambientOcclusion.call(context2);
    return super.construct(builder);
  }
  generate(builder) {
    const { context: context2 } = this;
    const type = this.getNodeType(builder);
    super.generate(builder, type);
    return context2.reflectedLight.total.build(builder, type);
  }
};
var LightingContextNode_default = LightingContextNode;

// node_modules/three/examples/jsm/nodes/utils/EquirectUVNode.js
var EquirectUVNode = class extends TempNode_default {
  constructor(dirNode = positionWorldDirection) {
    super("vec2");
    this.dirNode = dirNode;
  }
  construct() {
    const dir = nodeObject(this.dirNode);
    const u = add(mul(atan2(dir.z, dir.x), 1 / (Math.PI * 2)), 0.5);
    const v = add(mul(asin(clamp(dir.y, -1, 1)), 1 / Math.PI), 0.5);
    return vec2(u, v);
  }
};
var EquirectUVNode_default = EquirectUVNode;

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  construct() {
    const x = normalize(vec3(positionViewDirection.z, 0, negate(positionViewDirection.x)));
    const y = cross(positionViewDirection, x);
    return add(mul(vec2(dot(x, transformedNormalView), dot(y, transformedNormalView)), 0.495), 0.5);
  }
};
var MatcapUVNode_default = MatcapUVNode;

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var TimerNode = class extends UniformNode_default {
  constructor(scope = TimerNode.LOCAL, scale = 1, value = 0) {
    super(value);
    this.scope = scope;
    this.scale = scale;
    this.updateType = NodeUpdateType.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else if (scope === TimerNode.FRAME) {
      this.value = frame.frameId;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
TimerNode.LOCAL = "local";
TimerNode.GLOBAL = "global";
TimerNode.DELTA = "delta";
TimerNode.FRAME = "frame";
var TimerNode_default = TimerNode;

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var OscNode = class extends Node_default {
  constructor(method = OscNode.SINE, timeNode = new TimerNode_default()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  construct() {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode;
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
OscNode.SINE = "sine";
OscNode.SQUARE = "square";
OscNode.TRIANGLE = "triangle";
OscNode.SAWTOOTH = "sawtooth";
var OscNode_default = OscNode;

// node_modules/three/examples/jsm/nodes/utils/RemapNode.js
var RemapNode = class extends Node_default {
  constructor(node, inLowNode, inHighNode, outLowNode, outHighNode) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  construct() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = div(sub(node, inLowNode), sub(inHighNode, inLowNode));
    if (doClamp === true)
      t = clamp(t);
    return add(mul(sub(outHighNode, outLowNode), t), outLowNode);
  }
};
var RemapNode_default = RemapNode;

// node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js
var RotateUVNode = class extends TempNode_default {
  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {
    super("vec2");
    this.uvNode = uvNode;
    this.rotationNode = rotationNode;
    this.centerNode = centerNode;
  }
  construct() {
    const { uvNode, rotationNode, centerNode } = this;
    const cosAngle = cos(rotationNode);
    const sinAngle = sin(rotationNode);
    return vec2(
      add(add(mul(cosAngle, sub(uvNode.x, centerNode.x)), mul(sinAngle, sub(uvNode.y, centerNode.y))), centerNode.x),
      add(sub(mul(cosAngle, sub(uvNode.y, centerNode.y)), mul(sinAngle, sub(uvNode.x, centerNode.x))), centerNode.y)
    );
  }
};
var RotateUVNode_default = RotateUVNode;

// node_modules/three/examples/jsm/nodes/utils/SpecularMIPLevelNode.js
var SpecularMIPLevelNode = class extends Node_default {
  constructor(textureNode, roughnessNode = null) {
    super("float");
    this.textureNode = textureNode;
    this.roughnessNode = roughnessNode;
  }
  construct() {
    const { textureNode, roughnessNode } = this;
    const maxMIPLevelScalar = maxMipLevel(textureNode);
    const sigma = div(mul(Math.PI, mul(roughnessNode, roughnessNode)), add(1, roughnessNode));
    const desiredMIPLevel = add(maxMIPLevelScalar, log2(sigma));
    return clamp(desiredMIPLevel, 0, maxMIPLevelScalar);
  }
};
var SpecularMIPLevelNode_default = SpecularMIPLevelNode;

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = new UVNode_default(), frameNode = new ConstNode_default(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  construct() {
    const { frameNode, uvNode, countNode } = this;
    const one = new ConstNode_default(1);
    const width = new SplitNode_default(countNode, "x");
    const height = new SplitNode_default(countNode, "y");
    const total = new OperatorNode_default("*", width, height);
    const roundFrame = new MathNode_default(MathNode_default.FLOOR, new MathNode_default(MathNode_default.MOD, frameNode, total));
    const frameNum = new OperatorNode_default("+", roundFrame, one);
    const cell = new MathNode_default(MathNode_default.MOD, roundFrame, width);
    const row = new MathNode_default(MathNode_default.CEIL, new OperatorNode_default("/", frameNum, width));
    const rowInv = new OperatorNode_default("-", height, row);
    const scale = new OperatorNode_default("/", one, countNode);
    const uvFrameOffset = new JoinNode_default([
      new OperatorNode_default("*", cell, new SplitNode_default(scale, "x")),
      new OperatorNode_default("*", rowInv, new SplitNode_default(scale, "y"))
    ]);
    const uvScale = new OperatorNode_default("*", uvNode, scale);
    const uvFrame = new OperatorNode_default("+", uvScale, uvFrameOffset);
    return uvFrame;
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;

// node_modules/three/examples/jsm/nodes/utils/TriplanarTexturesNode.js
var TriplanarTexturesNode = class extends Node_default {
  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionWorld, normalNode = normalWorld) {
    super("vec4");
    this.textureXNode = textureXNode;
    this.textureYNode = textureYNode;
    this.textureZNode = textureZNode;
    this.scaleNode = scaleNode;
    this.positionNode = positionNode;
    this.normalNode = normalNode;
  }
  construct() {
    const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;
    let bf = normalize(abs(normalNode));
    bf = div(bf, dot(bf, vec3(1)));
    const tx = mul(positionNode.yz, scaleNode);
    const ty = mul(positionNode.zx, scaleNode);
    const tz = mul(positionNode.xy, scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = mul(texture(textureX, tx), bf.x);
    const cy = mul(texture(textureY, ty), bf.y);
    const cz = mul(texture(textureZ, tz), bf.z);
    return add(cx, cy, cz);
  }
};
var TriplanarTexturesNode_default = TriplanarTexturesNode;

// node_modules/three/examples/jsm/nodes/geometry/RangeNode.js
var RangeNode = class extends Node_default {
  constructor(min2, max2) {
    super();
    this.min = min2;
    this.max = max2;
  }
  getVectorLength() {
    const min2 = this.min;
    let length2 = 1;
    if (min2.isVector2)
      length2 = 2;
    else if (min2.isVector3)
      length2 = 3;
    else if (min2.isVector4)
      length2 = 4;
    else if (min2.isColor)
      length2 = 3;
    return length2;
  }
  getNodeType(builder) {
    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength()) : "float";
  }
  construct(builder) {
    const { min: min2, max: max2 } = this;
    const { object, geometry } = builder;
    let output = null;
    if (object.isInstancedMesh === true) {
      const vectorLength = this.getVectorLength();
      const attributeName = "node" + this.id;
      const length2 = vectorLength * object.count;
      const array = new Float32Array(length2);
      const attributeGeometry = geometry.getAttribute(attributeName);
      if (attributeGeometry === void 0 || attributeGeometry.array.length < length2) {
        if (vectorLength === 1) {
          for (let i = 0; i < length2; i++) {
            array[i] = MathUtils.lerp(min2, max2, Math.random());
          }
        } else if (min2.isColor) {
          for (let i = 0; i < length2; i += 3) {
            array[i] = MathUtils.lerp(min2.r, max2.r, Math.random());
            array[i + 1] = MathUtils.lerp(min2.g, max2.g, Math.random());
            array[i + 2] = MathUtils.lerp(min2.b, max2.b, Math.random());
          }
        } else {
          for (let i = 0; i < length2; i++) {
            const index = i % vectorLength;
            const minValue = min2.getComponent(index);
            const maxValue = max2.getComponent(index);
            array[i] = MathUtils.lerp(minValue, maxValue, Math.random());
          }
        }
        geometry.setAttribute(attributeName, new InstancedBufferAttribute(array, vectorLength));
        geometry.dispose();
      }
      output = attribute(attributeName, builder.getTypeFromLength(vectorLength));
    } else {
      output = float(0);
    }
    return output;
  }
};
var RangeNode_default = RangeNode;

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = mul(inputs.uv, 2);
  const cx = floor(uv2.x);
  const cy = floor(uv2.y);
  const result = mod(add(cx, cy), 2);
  return sign(result);
});
var CheckerNode = class extends TempNode_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  generate(builder) {
    return checkerShaderNode.call({ uv: this.uvNode }).build(builder);
  }
};
var CheckerNode_default = CheckerNode;

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  mix(outputNode) {
    return new MathNode_default(MathNode_default.MIX, outputNode, this.colorNode, this);
  }
  generate(builder) {
    return this.factorNode.build(builder, "float");
  }
};
var FogNode_default = FogNode;

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  construct() {
    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));
  }
};
var FogRangeNode_default = FogRangeNode;

// node_modules/three/examples/jsm/nodes/fog/FogExp2Node.js
var FogExp2Node = class extends FogNode_default {
  constructor(colorNode, densityNode) {
    super(colorNode);
    this.isFogExp2Node = true;
    this.densityNode = densityNode;
  }
  construct() {
    const depthNode = negate(positionView.z);
    const densityNode = this.densityNode;
    this.factorNode = sub(1, exp(mul(negate(densityNode), densityNode, depthNode, depthNode)));
  }
};
var FogExp2Node_default = FogExp2Node;

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = new ShaderNode((inputs) => {
  const { f0, f90, dotVH } = inputs;
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(sub(1, fresnel)).add(f90.mul(fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_BlinnPhong.js
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = new ShaderNode(({ dotNH }) => {
  return shininess.mul(1 / Math.PI).mul(0.5).add(1).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = new ShaderNode(({ lightDirection }) => {
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNH = clamp(dot(transformedNormalView, halfDir));
  const dotVH = clamp(dot(positionViewDirection, halfDir));
  const F = F_Schlick_default.call({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong.call({ dotNH });
  return mul(F, G, D);
});
var BRDF_BlinnPhong_default = BRDF_BlinnPhong;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const { alpha, dotNL, dotNV: dotNV2 } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV2)))));
  const gl = mul(dotNV2, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = new ShaderNode((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = new ShaderNode((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2 } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = clamp(dot(transformedNormalView, lightDirection));
  const dotNH = clamp(dot(transformedNormalView, halfDir));
  const dotVH = clamp(dot(positionViewDirection, halfDir));
  const F = F_Schlick_default.call({ f0, f90, dotVH });
  const V = V_GGX_SmithCorrelated_default.call({ alpha, dotNL, dotNV });
  const D = D_GGX_default.call({ alpha, dotNH });
  return mul(F, mul(V, D));
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/BSDF/DFGApprox.js
var DFGApprox = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness2.mul(c0).add(c1);
  const a004 = min(mul(r.x, r.x), dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
});
var DFGApprox_default = DFGApprox;

// node_modules/three/examples/jsm/nodes/functions/light/getDistanceAttenuation.js
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = div(1, max(pow(lightDistance, decayExponent), 0.01));
  return cond(
    greaterThan(cutoffDistance, 0),
    mul(distanceFalloff, pow2(clamp(sub(1, pow4(div(lightDistance, cutoffDistance)))))),
    distanceFalloff
  );
});
var getDistanceAttenuation_default = getDistanceAttenuation;

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = new ShaderNode(() => {
  const dxy = max(abs(dFdx(normalGeometry)), abs(dFdy(normalGeometry)));
  const geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default.call();
  let roughnessFactor = max(roughness2, 0.0525);
  roughnessFactor = add(roughnessFactor, geometryRoughness);
  roughnessFactor = min(roughnessFactor, 1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/PhongLightingModel.js
var RE_Direct_BlinnPhong = new ShaderNode(({ lightDirection, lightColor, reflectedLight }) => {
  const dotNL = clamp(dot(transformedNormalView, lightDirection));
  const irradiance = mul(dotNL, lightColor);
  reflectedLight.directDiffuse.add(mul(irradiance, BRDF_Lambert_default.call({ diffuseColor: diffuseColor.rgb })));
  reflectedLight.directSpecular.add(irradiance.mul(BRDF_BlinnPhong_default.call({ lightDirection })).mul(materialReflectivity));
});
var RE_IndirectDiffuse_BlinnPhong = new ShaderNode(({ irradiance, reflectedLight }) => {
  reflectedLight.indirectDiffuse.add(irradiance.mul(BRDF_Lambert_default.call({ diffuseColor })));
});
var phongLightingModel = lightingModel(RE_Direct_BlinnPhong, RE_IndirectDiffuse_BlinnPhong);
var PhongLightingModel_default = phongLightingModel;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var computeMultiscattering = (singleScatter, multiScatter, specularF90 = 1) => {
  const fab = DFGApprox_default.call({ roughness });
  const FssEss = add(mul(specularColor, fab.x), mul(specularF90, fab.y));
  const Ess = add(fab.x, fab.y);
  const Ems = sub(1, Ess);
  const Favg = add(specularColor, mul(sub(1, specularColor), 0.047619));
  const Fms = div(mul(FssEss, Favg), sub(1, mul(Ems, Favg)));
  singleScatter.add(FssEss);
  multiScatter.add(mul(Fms, Ems));
};
var RE_IndirectSpecular_Physical = new ShaderNode((inputs) => {
  const { radiance, iblIrradiance, reflectedLight } = inputs;
  const singleScattering = temp(vec3());
  const multiScattering = temp(vec3());
  const cosineWeightedIrradiance = mul(iblIrradiance, 1 / Math.PI);
  computeMultiscattering(singleScattering, multiScattering);
  const diffuse = mul(diffuseColor, sub(1, add(singleScattering, multiScattering)));
  reflectedLight.indirectSpecular.add(mul(radiance, singleScattering));
  reflectedLight.indirectSpecular.add(mul(multiScattering, cosineWeightedIrradiance));
  reflectedLight.indirectDiffuse.add(mul(diffuse, cosineWeightedIrradiance));
});
var RE_IndirectDiffuse_Physical = new ShaderNode((inputs) => {
  const { irradiance, reflectedLight } = inputs;
  reflectedLight.indirectDiffuse.add(mul(irradiance, BRDF_Lambert_default.call({ diffuseColor })));
});
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const { lightDirection, lightColor, reflectedLight } = inputs;
  const dotNL = clamp(dot(transformedNormalView, lightDirection));
  const irradiance = mul(dotNL, lightColor);
  reflectedLight.directDiffuse.add(mul(irradiance, BRDF_Lambert_default.call({ diffuseColor: diffuseColor.rgb })));
  reflectedLight.directSpecular.add(mul(irradiance, BRDF_GGX_default.call({ lightDirection, f0: specularColor, f90: 1, roughness })));
});
var RE_AmbientOcclusion_Physical = new ShaderNode(({ ambientOcclusion, reflectedLight }) => {
  const aoNV = add(dotNV, ambientOcclusion);
  const aoExp = exp2(sub(mul(-16, roughness), 1));
  const aoNode = clamp(add(sub(pow(aoNV, aoExp), 1), ambientOcclusion));
  reflectedLight.indirectDiffuse.mul(ambientOcclusion);
  reflectedLight.indirectSpecular.mul(aoNode);
});
var physicalLightingModel = lightingModel(RE_Direct_Physical, RE_IndirectDiffuse_Physical, RE_IndirectSpecular_Physical, RE_AmbientOcclusion_Physical);
var PhysicalLightingModel_default = physicalLightingModel;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeElements.js
var cubeTexture = nodeProxy(CubeTextureNode_default);
var instance = nodeProxy(InstanceNode_default);
var reflectVector = nodeImmutable(ReflectVectorNode_default);
var skinning = nodeProxy(SkinningNode_default);
var materialNormal = nodeImmutable(ExtendedMaterialNode_default, ExtendedMaterialNode_default.NORMAL);
var burn = nodeProxy(BlendModeNode_default, BlendModeNode_default.BURN);
var dodge = nodeProxy(BlendModeNode_default, BlendModeNode_default.DODGE);
var overlay = nodeProxy(BlendModeNode_default, BlendModeNode_default.OVERLAY);
var screen = nodeProxy(BlendModeNode_default, BlendModeNode_default.SCREEN);
var saturation = nodeProxy(ColorAdjustmentNode_default, ColorAdjustmentNode_default.SATURATION);
var vibrance = nodeProxy(ColorAdjustmentNode_default, ColorAdjustmentNode_default.VIBRANCE);
var hue = nodeProxy(ColorAdjustmentNode_default, ColorAdjustmentNode_default.HUE);
var colorSpace = (node, encoding) => nodeObject(new ColorSpaceNode_default(null, nodeObject(node)).fromEncoding(encoding));
var normalMap = nodeProxy(NormalMapNode_default);
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode_default(mapping, nodeObject(exposure), nodeObject(color2)));
var posterize = nodeProxy(PosterizeNode_default);
var viewportCoordinate = nodeImmutable(ViewportNode_default, ViewportNode_default.COORDINATE);
var viewportResolution = nodeImmutable(ViewportNode_default, ViewportNode_default.RESOLUTION);
var viewportTopLeft = nodeImmutable(ViewportNode_default, ViewportNode_default.TOP_LEFT);
var viewportBottomLeft = nodeImmutable(ViewportNode_default, ViewportNode_default.BOTTOM_LEFT);
var viewportTopRight = nodeImmutable(ViewportNode_default, ViewportNode_default.TOP_RIGHT);
var viewportBottomRight = nodeImmutable(ViewportNode_default, ViewportNode_default.BOTTOM_RIGHT);
var lights = (lights2) => nodeObject(new LightsNode_default().fromLights(lights2));
var lightingContext = nodeProxy(LightingContextNode_default);
var matcapUV = nodeImmutable(MatcapUVNode_default);
var equirectUV = nodeProxy(EquirectUVNode_default);
var specularMIPLevel = nodeProxy(SpecularMIPLevelNode_default);
var oscSine = nodeProxy(OscNode_default, OscNode_default.SINE);
var oscSquare = nodeProxy(OscNode_default, OscNode_default.SQUARE);
var oscTriangle = nodeProxy(OscNode_default, OscNode_default.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode_default, OscNode_default.SAWTOOTH);
var remap = nodeProxy(RemapNode_default, null, null, { doClamp: false });
var remapClamp = nodeProxy(RemapNode_default);
var rotateUV = nodeProxy(RotateUVNode_default);
var spritesheetUV = nodeProxy(SpriteSheetUVNode_default);
var timerLocal = (timeScale, value = 0) => nodeObject(new TimerNode_default(TimerNode_default.LOCAL, timeScale, value));
var timerGlobal = (timeScale, value = 0) => nodeObject(new TimerNode_default(TimerNode_default.GLOBAL, timeScale, value));
var timerDelta = (timeScale, value = 0) => nodeObject(new TimerNode_default(TimerNode_default.DELTA, timeScale, value));
var frameId = nodeImmutable(TimerNode_default, TimerNode_default.FRAME);
var triplanarTextures = nodeProxy(TriplanarTexturesNode_default);
var triplanarTexture = (texture2, ...params) => triplanarTextures(texture2, texture2, texture2, ...params);
var range = (min2, max2) => nodeObject(new RangeNode_default(min2, max2));
var checker = nodeProxy(CheckerNode_default);
var fog = nodeProxy(FogNode_default);
var rangeFog = nodeProxy(FogRangeNode_default);
var densityFog = nodeProxy(FogExp2Node_default);

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["construct", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vector = ["x", "y", "z", "w"];
var typeFromLength = /* @__PURE__ */ new Map();
typeFromLength.set(2, "vec2");
typeFromLength.set(3, "vec3");
typeFromLength.set(4, "vec4");
typeFromLength.set(9, "mat3");
typeFromLength.set(16, "mat4");
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser) {
    this.object = object;
    this.material = object.material || null;
    this.geometry = object.geometry || null;
    this.renderer = renderer;
    this.parser = parser;
    this.nodes = [];
    this.updateNodes = [];
    this.hashNodes = {};
    this.scene = null;
    this.lightsNode = null;
    this.fogNode = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: [] };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.codes = { vertex: [], fragment: [], compute: [] };
    this.attributes = [];
    this.varyings = [];
    this.vars = { vertex: [], fragment: [], compute: [] };
    this.flow = { code: "" };
    this.stack = [];
    this.context = {
      keywords: new NodeKeywords_default(),
      material: object.material,
      getMIPLevelAlgorithmNode: (textureNode, levelNode) => mul(levelNode, maxMipLevel(textureNode))
    };
    this.cache = new NodeCache_default();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
  }
  get node() {
    return this.stack[this.stack.length - 1];
  }
  addStack(node) {
    this.stack.push(node);
  }
  removeStack(node) {
    const lastStack = this.stack.pop();
    if (lastStack !== node) {
      throw new Error("NodeBuilder: Invalid node stack!");
    }
  }
  setHashNode(node, hash) {
    this.hashNodes[hash] = node;
  }
  addNode(node) {
    if (this.nodes.indexOf(node) === -1) {
      const updateType = node.getUpdateType(this);
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node);
      }
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash) {
    return this.hashNodes[hash];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context2) {
    this.context = context2;
  }
  getContext() {
    return this.context;
  }
  setCache(cache2) {
    this.cache = cache2;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return false;
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return false;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  getCubeTexture() {
    console.warn("Abstract function.");
  }
  getCubeTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint")
        value = 0;
      else if (type === "bool")
        value = false;
      else if (type === "color")
        value = new Color();
      else if (type === "vec2")
        value = new Vector2();
      else if (type === "vec3")
        value = new Vector3();
      else if (type === "vec4")
        value = new Vector4();
    }
    if (type === "float")
      return toFloat(value);
    if (type === "int")
      return `${Math.round(value)}`;
    if (type === "uint")
      return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool")
      return value ? "true" : "false";
    if (type === "color")
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const getConst = (value2) => this.getConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  getType(type) {
    return type;
  }
  generateMethod(method) {
    return method;
  }
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type) {
    return /vec\d/.test(type);
  }
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "texture" || type === "cubeTexture";
  }
  isShaderStage(shaderStage) {
    return this.shaderStage === shaderStage;
  }
  getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint")
      return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null)
      return null;
    if (componentType[1] === "b")
      return "bool";
    if (componentType[1] === "i")
      return "int";
    if (componentType[1] === "u")
      return "uint";
    return "float";
  }
  getVectorType(type) {
    if (type === "color")
      return "vec3";
    if (type === "texture")
      return "vec4";
    return type;
  }
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1)
      return componentType;
    const baseType = typeFromLength.get(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    return prefix + baseType;
  }
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null)
      return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint")
      return 1;
    if (/mat3/.test(type) === true)
      return 9;
    if (/mat4/.test(type) === true)
      return 16;
    return 0;
  }
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint")
      return type;
    return this.changeComponentType(type, "int");
  }
  getDataFromNode(node, shaderStage = this.shaderStage) {
    const cache2 = node.isGlobal(this) ? this.globalCache : this.cache;
    let nodeData = cache2.getNodeData(node);
    if (nodeData === void 0) {
      nodeData = { vertex: {}, fragment: {}, compute: {} };
      cache2.setNodeData(node, nodeData);
    }
    return shaderStage !== null ? nodeData[shaderStage] : nodeData;
  }
  getNodeProperties(node, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  getUniformFromNode(node, shaderStage, type) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default("nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage];
      const index = vars.length;
      nodeVar = new NodeVar_default("nodeVar" + index, type);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryingFromNode(node, type) {
    const nodeData = this.getDataFromNode(node, null);
    let nodeVarying = nodeData.varying;
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      nodeVarying = new NodeVarying_default("nodeVarying" + index, type);
      varyings.push(nodeVarying);
      nodeData.varying = nodeVarying;
    }
    return nodeVarying;
  }
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage];
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addFlowCode(code2, breakline = true) {
    if (breakline && !/;\s*$/.test(code2)) {
      code2 += ";\n	";
    }
    this.flow.code += code2;
  }
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    const output = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  flowChildNode(node, output = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output);
    if (propertyName !== null) {
      flowData.code += `${propertyName} = ${flowData.result};
	`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    for (const variable of vars) {
      snippet += `${variable.type} ${variable.name}; `;
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    for (const nodeCode of codes) {
      code2 += nodeCode.code + "\n";
    }
    return code2;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    return this;
  }
  format(snippet, fromType2, toType) {
    fromType2 = this.getVectorType(fromType2);
    toType = this.getVectorType(toType);
    if (fromType2 === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType2);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);
    }
    if (toTypeLength === 4) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType2, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType2, "vec2")}, 0.0 )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three/examples/jsm/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.startTime = null;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
  }
  updateNode(node) {
    if (node.updateType === NodeUpdateType.FRAME) {
      if (this.updateMap.get(node) !== this.frameId) {
        this.updateMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (node.updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0)
      this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three/examples/jsm/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three/examples/jsm/nodes/lighting/PointLightNode.js
var PointLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  construct(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation_default.call({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(lightAttenuation);
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    const reflectedLight = builder.context.reflectedLight;
    if (lightingModelFunctionNode && lightingModelFunctionNode.direct) {
      lightingModelFunctionNode.direct.call({
        lightDirection,
        lightColor,
        reflectedLight
      }, builder);
    }
  }
};
LightsNode_default.setReference(PointLight, PointLightNode);
var PointLightNode_default = PointLightNode;

// node_modules/three/examples/jsm/nodes/functions/light/getDirectionVector.js
var vector3;
var getDirectionVector = (light, camera, directionVector) => {
  vector3 || (vector3 = new Vector3());
  directionVector.setFromMatrixPosition(light.matrixWorld);
  vector3.setFromMatrixPosition(light.target.matrixWorld);
  directionVector.sub(vector3);
  directionVector.transformDirection(camera.matrixWorldInverse);
};
var getDirectionVector_default = getDirectionVector;

// node_modules/three/examples/jsm/nodes/lighting/DirectionalLightNode.js
var DirectionalLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.directionNode = uniform(new Vector3());
  }
  update(frame) {
    getDirectionVector_default(this.light, frame.camera, this.directionNode.value);
    super.update(frame);
  }
  construct(builder) {
    const lightDirection = this.directionNode.normalize();
    const lightColor = this.colorNode;
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    const reflectedLight = builder.context.reflectedLight;
    if (lightingModelFunctionNode && lightingModelFunctionNode.direct) {
      lightingModelFunctionNode.direct.call({
        lightDirection,
        lightColor,
        reflectedLight
      }, builder);
    }
  }
};
LightsNode_default.setReference(DirectionalLight, DirectionalLightNode);
var DirectionalLightNode_default = DirectionalLightNode;

// node_modules/three/examples/jsm/nodes/lighting/SpotLightNode.js
var SpotLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.directionNode = uniform(new Vector3());
    this.coneCosNode = uniform(0);
    this.penumbraCosNode = uniform(0);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    super.update(frame);
    const { light } = this;
    getDirectionVector_default(light, frame.camera, this.directionNode.value);
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  getSpotAttenuation(angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  construct(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const angleCos = lightDirection.dot(this.directionNode);
    const spotAttenuation = this.getSpotAttenuation(angleCos);
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation_default.call({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const finalColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    const lightColor = spotAttenuation.greaterThan(0).cond(finalColor, 0);
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    const reflectedLight = builder.context.reflectedLight;
    if (lightingModelFunctionNode && lightingModelFunctionNode.direct) {
      lightingModelFunctionNode.direct.call({
        lightDirection,
        lightColor,
        reflectedLight
      }, builder);
    }
  }
};
LightsNode_default.setReference(SpotLight, SpotLightNode);
var SpotLightNode_default = SpotLightNode;

// node_modules/three/examples/jsm/lights/IESSpotLight.js
var IESSpotLight = class extends SpotLight {
  constructor(color2, intensity, distance2, angle, penumbra, decay) {
    super(color2, intensity, distance2, angle, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
};
var IESSpotLight_default = IESSpotLight;

// node_modules/three/examples/jsm/nodes/lighting/IESSpotLightNode.js
var IESSpotLightNode = class extends SpotLightNode_default {
  getSpotAttenuation(angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle = acos(angleCosine).mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
LightsNode_default.setReference(IESSpotLight_default, IESSpotLightNode);
var IESSpotLightNode_default = IESSpotLightNode;

// node_modules/three/examples/jsm/nodes/lighting/AmbientLightNode.js
var AmbientLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  construct({ context: context2 }) {
    context2.irradiance.add(this.colorNode);
  }
};
LightsNode_default.setReference(AmbientLight, AmbientLightNode);
var AmbientLightNode_default = AmbientLightNode;

// node_modules/three/examples/jsm/nodes/lighting/HemisphereLightNode.js
var HemisphereLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.lightPositionNode = new Object3DNode_default(Object3DNode_default.POSITION);
    this.lightDirectionNode = normalize(this.lightPositionNode);
    this.groundColorNode = uniform(new Color());
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  generate(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = dot(normalView, lightDirectionNode);
    const hemiDiffuseWeight = add(mul(0.5, dotNL), 0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.add(irradiance);
  }
};
LightsNode_default.setReference(HemisphereLight, HemisphereLightNode);
var HemisphereLightNode_default = HemisphereLightNode;

// node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js
var EnvironmentNode = class extends LightingNode_default {
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  construct(builder) {
    const envNode = this.envNode;
    const properties = builder.getNodeProperties(this);
    let reflectVec;
    let radianceTextureUVNode;
    let irradianceTextureUVNode;
    const radianceContext = new ContextNode_default(envNode, {
      getUVNode: (textureNode) => {
        let node = null;
        if (reflectVec === void 0) {
          reflectVec = positionViewDirection.negate().reflect(transformedNormalView);
          reflectVec = reflectVec.mix(transformedNormalView, roughness.mul(roughness)).normalize();
          reflectVec = reflectVec.transformDirection(cameraViewMatrix);
        }
        if (textureNode.isCubeTextureNode) {
          node = reflectVec;
        } else if (textureNode.isTextureNode) {
          if (radianceTextureUVNode === void 0) {
            radianceTextureUVNode = equirectUV(reflectVec);
            radianceTextureUVNode = vec2(radianceTextureUVNode.x, radianceTextureUVNode.y.invert());
          }
          node = radianceTextureUVNode;
        }
        return node;
      },
      getSamplerLevelNode: () => {
        return roughness;
      },
      getMIPLevelAlgorithmNode: (textureNode, levelNode) => {
        return new SpecularMIPLevelNode_default(textureNode, levelNode);
      }
    });
    const irradianceContext = new ContextNode_default(envNode, {
      getUVNode: (textureNode) => {
        let node = null;
        if (textureNode.isCubeTextureNode) {
          node = transformedNormalWorld;
        } else if (textureNode.isTextureNode) {
          if (irradianceTextureUVNode === void 0) {
            irradianceTextureUVNode = equirectUV(transformedNormalWorld);
            irradianceTextureUVNode = vec2(irradianceTextureUVNode.x, irradianceTextureUVNode.y.invert());
          }
          node = irradianceTextureUVNode;
        }
        return node;
      },
      getSamplerLevelNode: () => {
        return float(1);
      },
      getMIPLevelAlgorithmNode: (textureNode, levelNode) => {
        return new SpecularMIPLevelNode_default(textureNode, levelNode);
      }
    });
    const isolateRadianceFlowContext = new CacheNode_default(radianceContext);
    builder.context.radiance.add(isolateRadianceFlowContext);
    builder.context.iblIrradiance.add(mul(Math.PI, irradianceContext));
    properties.radianceContext = isolateRadianceFlowContext;
    properties.irradianceContext = irradianceContext;
  }
};
var EnvironmentNode_default = EnvironmentNode;

// node_modules/three/examples/jsm/nodes/lighting/AONode.js
var AONode = class extends LightingNode_default {
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  construct(builder) {
    const aoIntensity = 1;
    const aoNode = add(mul(sub(float(this.aoNode), 1), aoIntensity), 1);
    builder.context.ambientOcclusion.mul(aoNode);
  }
};
var AONode_default = AONode;

// node_modules/three/examples/jsm/nodes/loaders/NodeLoader.js
var NodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parseNodes(json) {
    const nodes = {};
    if (json !== void 0) {
      for (const nodeJSON of json) {
        const { uuid, type } = nodeJSON;
        nodes[uuid] = fromType(type);
        nodes[uuid].uuid = uuid;
      }
      const meta = { nodes, textures: this.textures };
      for (const nodeJSON of json) {
        nodeJSON.meta = meta;
        const node = nodes[nodeJSON.uuid];
        node.deserialize(nodeJSON);
        delete nodeJSON.meta;
      }
    }
    return nodes;
  }
  parse(json) {
    const node = fromType(json.type);
    node.uuid = json.uuid;
    const nodes = this.parseNodes(json.inputNodes);
    const meta = { nodes, textures: this.textures };
    json.meta = meta;
    node.deserialize(json);
    delete json.meta;
    return node;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var NodeLoader_default = NodeLoader;

// node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js
var NodeMaterial = class extends ShaderMaterial {
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.type = this.constructor.name;
    this.lights = true;
    this.normals = true;
    this.lightsNode = null;
  }
  customProgramCacheKey() {
    return getCacheKey(this);
  }
  build(builder) {
    this.construct(builder);
  }
  construct(builder) {
    const vertexStack = new StackNode_default();
    const fragmentStack = new StackNode_default();
    vertexStack.outputNode = this.constructPosition(builder, vertexStack);
    if (this.normals === true)
      this.constructNormal(builder, fragmentStack);
    this.constructDiffuseColor(builder, fragmentStack);
    this.constructVariants(builder, fragmentStack);
    const outgoingLightNode = this.constructLighting(builder, fragmentStack);
    fragmentStack.outputNode = this.constructOutput(builder, fragmentStack, outgoingLightNode, diffuseColor.a);
    builder.addFlow("vertex", vertexStack);
    builder.addFlow("fragment", fragmentStack);
  }
  constructPosition(builder) {
    const object = builder.object;
    let vertex = positionLocal;
    if (this.positionNode !== null) {
      vertex = bypass(vertex, assign(positionLocal, this.positionNode));
    }
    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable("instance") === true) {
      vertex = bypass(vertex, instance(object));
    }
    if (object.isSkinnedMesh === true) {
      vertex = bypass(vertex, skinning(object));
    }
    builder.context.vertex = vertex;
    return modelViewProjection();
  }
  constructDiffuseColor(builder, stack) {
    let colorNode = vec4(this.colorNode || materialColor);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    if (this.vertexColors === true && builder.geometry.hasAttribute("color")) {
      colorNode = vec4(mul(colorNode.xyz, attribute("color")), colorNode.a);
    }
    stack.assign(diffuseColor, colorNode);
    stack.assign(diffuseColor.a, diffuseColor.a.mul(opacityNode));
    if (this.alphaTestNode || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode ? float(this.alphaTestNode) : materialAlphaTest;
      stack.add(discard(lessThanEqual(diffuseColor.a, alphaTestNode)));
    }
  }
  constructVariants() {
  }
  constructNormal(builder, stack) {
    const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;
    stack.assign(transformedNormalView, normalNode);
    return normalNode;
  }
  constructLights(builder) {
    let lightsNode = this.lightsNode || builder.lightsNode;
    const envNode = this.envNode || builder.scene.environmentNode;
    const materialLightsNode = [];
    if (envNode) {
      materialLightsNode.push(new EnvironmentNode_default(envNode));
    }
    if (builder.material.aoMap) {
      materialLightsNode.push(new AONode_default(texture(builder.material.aoMap)));
    }
    if (materialLightsNode.length > 0) {
      lightsNode = new LightsNode_default([...lightsNode.lightNodes, ...materialLightsNode]);
    }
    return lightsNode;
  }
  constructLightingModel() {
  }
  constructLighting(builder) {
    const { material } = builder;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights2 ? this.constructLights(builder) : null;
    const lightingModelNode = lightsNode ? this.constructLightingModel(builder) : null;
    let outgoingLightNode = diffuseColor.xyz;
    if (lightsNode && lightsNode.hasLight !== false) {
      outgoingLightNode = lightingContext(lightsNode, lightingModelNode);
    }
    if (this.emissiveNode && this.emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      outgoingLightNode = outgoingLightNode.add(vec3(this.emissiveNode || materialEmissive));
    }
    return outgoingLightNode;
  }
  constructOutput(builder, stack, outgoingLight, opacity) {
    const renderer = builder.renderer;
    let toneMappingNode = renderer.toneMappingNode;
    if (!toneMappingNode && renderer.toneMapping !== NoToneMapping) {
      toneMappingNode = new ToneMappingNode_default(renderer.toneMapping, reference("toneMappingExposure", "float", renderer), outgoingLight);
    }
    if (toneMappingNode && toneMappingNode.isNode === true) {
      outgoingLight = context(toneMappingNode, { color: outgoingLight });
    }
    let outputNode = vec4(outgoingLight, opacity);
    outputNode = colorSpace(outputNode, renderer.outputEncoding);
    let fogNode = builder.fogNode;
    if (fogNode && fogNode.isNode !== true && builder.scene.fog) {
      const fog2 = builder.scene.fog;
      if (fog2.isFogExp2) {
        fogNode = densityFog(reference("color", "color", fog2), reference("density", "float", fog2));
      } else if (fog2.isFog) {
        fogNode = rangeFog(reference("color", "color", fog2), reference("near", "float", fog2), reference("far", "float", fog2));
      } else {
        console.error("NodeMaterial: Unsupported fog configuration.", fog2);
      }
    }
    if (fogNode)
      outputNode = vec4(vec3(fogNode.mix(outputNode)), outputNode.w);
    return outputNode;
  }
  setDefaultValues(values) {
    for (const property2 in values) {
      const value = values[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone)
          this[property2] = value.clone();
      }
    }
    Object.assign(this.defines, values.defines);
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeKeys = getNodesKeys(this);
    data.inputNodes = {};
    for (const name of nodeKeys) {
      data.inputNodes[name] = this[name].toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
  static fromMaterial() {
  }
};
var NodeMaterial_default = NodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js
var defaultValues = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var LineBasicNodeMaterial_default = LineBasicNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues2 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = false;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var MeshBasicNodeMaterial_default = MeshBasicNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/MeshPhongNodeMaterial.js
var defaultValues3 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.shininessNode = null;
    this.specularNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues3);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return PhongLightingModel_default;
  }
  constructVariants(builder, stack) {
    const shininessNode = float(this.shininessNode || materialShininess).max(1e-4);
    stack.assign(shininess, shininessNode);
    const specularNode = vec3(this.specularNode || materialSpecularColor);
    stack.assign(specularColor, specularNode);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var MeshPhongNodeMaterial_default = MeshPhongNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues4 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.normalNode = null;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.envNode = null;
    this.lightsNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues4);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return PhysicalLightingModel_default;
  }
  constructVariants(builder, stack) {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    stack.assign(metalness, metalnessNode);
    stack.assign(diffuseColor, vec4(diffuseColor.rgb.mul(metalnessNode.invert()), diffuseColor.a));
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness_default.call({ roughness: roughnessNode });
    stack.assign(roughness, roughnessNode);
    const specularColorNode = mix(vec3(0.04), materialColor.rgb, metalnessNode);
    stack.assign(specularColor, specularColorNode);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.normalNode = source.normalNode;
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    this.envNode = source.envNode;
    this.lightsNode = source.lightsNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};

// node_modules/three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js
var defaultValues5 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial {
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.sheen = 0;
    this.clearcoat = 0;
    this.iridescence = 0;
    this.transmission = 0;
    this.setDefaultValues(defaultValues5);
    this.setValues(parameters);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    return super.copy(source);
  }
};

// node_modules/three/examples/jsm/nodes/materials/PointsNodeMaterial.js
var defaultValues6 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isPointsNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.transparent = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.sizeNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues6);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.sizeNode = source.sizeNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var PointsNodeMaterial_default = PointsNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/SpriteNodeMaterial.js
var defaultValues7 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.setDefaultValues(defaultValues7);
    this.setValues(parameters);
  }
  constructPosition({ object, context: context2 }) {
    const { positionNode, rotationNode, scaleNode } = this;
    const vertex = positionLocal;
    let mvPosition = mul(modelViewMatrix, positionNode ? vec4(positionNode.xyz, 1) : vec4(0, 0, 0, 1));
    let scale = vec2(
      vec3(modelWorldMatrix[0].x, modelWorldMatrix[0].y, modelWorldMatrix[0].z).length(),
      vec3(modelWorldMatrix[1].x, modelWorldMatrix[1].y, modelWorldMatrix[1].z).length()
    );
    if (scaleNode !== null) {
      scale = scale.mul(scaleNode);
    }
    let alignedPosition = vertex.xy;
    if (object.center && object.center.isVector2 === true) {
      alignedPosition = alignedPosition.sub(uniform(object.center).sub(vec2(0.5)));
    }
    alignedPosition = mul(alignedPosition, scale);
    const rotation = rotationNode || materialRotation;
    const rotatedPosition = vec2(
      cos(rotation).mul(alignedPosition.x).sub(sin(rotation).mul(alignedPosition.y)),
      sin(rotation).mul(alignedPosition.x).add(cos(rotation).mul(alignedPosition.y))
    );
    mvPosition = vec4(mvPosition.xy.add(rotatedPosition.xy), mvPosition.z, mvPosition.w);
    const modelViewProjection2 = cameraProjectionMatrix.mul(mvPosition);
    context2.vertex = vertex;
    return modelViewProjection2;
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
};
var SpriteNodeMaterial_default = SpriteNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/Materials.js
NodeMaterial_default.fromMaterial = function(material) {
  const materialLib = {
    NodeMaterial: NodeMaterial_default,
    LineBasicNodeMaterial: LineBasicNodeMaterial_default,
    MeshBasicNodeMaterial: MeshBasicNodeMaterial_default,
    MeshPhongNodeMaterial: MeshPhongNodeMaterial_default,
    MeshStandardNodeMaterial,
    MeshPhysicalNodeMaterial,
    PointsNodeMaterial: PointsNodeMaterial_default,
    SpriteNodeMaterial: SpriteNodeMaterial_default
  };
  const type = material.type.replace("Material", "NodeMaterial");
  if (materialLib[type] === void 0) {
    if (material.isNodeMaterial !== true) {
      throw new Error(`NodeMaterial: Material "${material.type}" is not compatible.`);
    }
    return material;
  }
  const nodeMaterial = new materialLib[type]();
  for (const key in material) {
    nodeMaterial[key] = material[key];
  }
  return nodeMaterial;
};

// node_modules/three/examples/jsm/nodes/loaders/NodeMaterialLoader.js
var superFromTypeFunction = MaterialLoader.createMaterialFromType;
MaterialLoader.createMaterialFromType = function(type) {
  const materialLib = {
    NodeMaterial: NodeMaterial_default,
    LineBasicNodeMaterial: LineBasicNodeMaterial_default,
    MeshBasicNodeMaterial: MeshBasicNodeMaterial_default,
    MeshStandardNodeMaterial,
    MeshPhysicalNodeMaterial,
    PointsNodeMaterial: PointsNodeMaterial_default,
    SpriteNodeMaterial: SpriteNodeMaterial_default
  };
  if (materialLib[type] !== void 0) {
    return new materialLib[type]();
  }
  return superFromTypeFunction.call(this, type);
};
var NodeMaterialLoader = class extends MaterialLoader {
  constructor(manager) {
    super(manager);
    this.nodes = {};
  }
  parse(json) {
    const material = super.parse(json);
    const nodes = this.nodes;
    const inputNodes = json.inputNodes;
    for (const property2 in inputNodes) {
      const uuid = inputNodes[property2];
      material[property2] = nodes[uuid];
    }
    return material;
  }
  setNodes(value) {
    this.nodes = value;
    return this;
  }
};
var NodeMaterialLoader_default = NodeMaterialLoader;

// node_modules/three/examples/jsm/nodes/loaders/NodeObjectLoader.js
var NodeObjectLoader = class extends ObjectLoader {
  constructor(manager) {
    super(manager);
    this._nodesJSON = null;
  }
  parse(json, onLoad) {
    this._nodesJSON = json.nodes;
    const data = super.parse(json, onLoad);
    this._nodesJSON = null;
    return data;
  }
  parseNodes(json, textures) {
    if (json !== void 0) {
      const loader = new NodeLoader_default();
      loader.setTextures(textures);
      return loader.parseNodes(json);
    }
    return {};
  }
  parseMaterials(json, textures) {
    const materials = {};
    if (json !== void 0) {
      const nodes = this.parseNodes(this._nodesJSON, textures);
      const loader = new NodeMaterialLoader_default();
      loader.setTextures(textures);
      loader.setNodes(nodes);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        materials[data.uuid] = loader.parse(data);
      }
    }
    return materials;
  }
};
var NodeObjectLoader_default = NodeObjectLoader;

// node_modules/three/examples/jsm/nodes/core/NodeParser.js
var NodeParser = class {
  parseFunction() {
    console.warn("Abstract function.");
  }
};
var NodeParser_default = NodeParser;

// node_modules/three/examples/jsm/nodes/core/NodeFunction.js
var NodeFunction = class {
  constructor(type, inputs, name = "", presicion = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.presicion = presicion;
  }
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var NodeFunction_default = NodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/WGSLNodeFunction.js
var declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+)?/i;
var propertiesRegexp = /[a-z_0-9]+/ig;
var wgslTypeLib = {
  f32: "float"
};
var parse = (source) => {
  source = source.trim();
  const declaration = source.match(declarationRegexp);
  if (declaration !== null && declaration.length === 4) {
    const inputsCode = declaration[2];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const name2 = propsMatches[i++][0];
      let type2 = propsMatches[i++][0];
      type2 = wgslTypeLib[type2] || type2;
      if (i < propsMatches.length && /^[fui]\d{2}$/.test(propsMatches[i][0]) === true)
        i++;
      inputs.push(new NodeFunctionInput_default(type2, name2));
    }
    const blockCode = source.substring(declaration[0].length);
    const name = declaration[1] !== void 0 ? declaration[1] : "";
    const type = declaration[3] || "void";
    return {
      type,
      inputs,
      name,
      inputsCode,
      blockCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a WGSL code.");
  }
};
var WGSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, inputsCode, blockCode } = parse(source);
    super(type, inputs, name);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
  }
  getCode(name = this.name) {
    const type = this.type !== "void" ? "-> " + this.type : "";
    return `fn ${name} ( ${this.inputsCode.trim()} ) ${type}` + this.blockCode;
  }
};
var WGSLNodeFunction_default = WGSLNodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/WGSLNodeParser.js
var WGSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new WGSLNodeFunction_default(source);
  }
};
var WGSLNodeParser_default = WGSLNodeParser;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js
var declarationRegexp2 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp2 = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse2 = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp2);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp2.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const isConst = propsMatches[i][0] === "const";
      if (isConst === true) {
        i++;
      }
      let qualifier = propsMatches[i][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i++][0];
      let count = Number.parseInt(propsMatches[i][0]);
      if (Number.isNaN(count) === false)
        i++;
      else
        count = null;
      const name2 = propsMatches[i++][0];
      inputs.push(new NodeFunctionInput_default(type2, name2, count, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const presicion = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      presicion,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse2(source);
    super(type, inputs, name, presicion);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, presicion } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (presicion !== "") {
        declarationCode = `${presicion} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
};
var GLSLNodeFunction_default = GLSLNodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeParser.js
var GLSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new GLSLNodeFunction_default(source);
  }
};
var GLSLNodeParser_default = GLSLNodeParser;

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js
var mx_noise = code(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`);
var includes = [mx_noise];
var mx_perlin_noise_float = fn("float mx_perlin_noise_float( any p )", includes);
var mx_perlin_noise_vec2 = fn("vec2 mx_perlin_noise_vec2( any p )", includes);
var mx_perlin_noise_vec3 = fn("vec3 mx_perlin_noise_vec3( any p )", includes);
var mx_cell_noise_float = fn("float mx_cell_noise_float( vec3 p )", includes);
var mx_worley_noise_float = fn("float mx_worley_noise_float( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec2 = fn("float mx_worley_noise_vec2( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec3 = fn("float mx_worley_noise_vec3( any p, float jitter, int metric )", includes);
var mx_fractal_noise_float = fn("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec2 = fn("float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec3 = fn("float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec4 = fn("float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", includes);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js
var mx_hsvtorgb = fn(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`);
var mx_rgbtohsv = fn(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_transform_color.js
var mx_transform_color = code(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`);
var includes2 = [mx_transform_color];
var mx_srgb_texture_to_lin_rec709 = fn("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", includes2);

// node_modules/three/examples/jsm/nodes/materialx/MaterialXNodes.js
var mx_aastep = (threshold, value) => {
  threshold = float(threshold);
  value = float(value);
  const afwidth = mul(length(vec2(dFdx(value), dFdy(value))), 0.7071067811865476);
  return smoothstep(sub(threshold, afwidth), add(threshold, afwidth), value);
};
var _ramp = (a, b, uv2, p) => mix(a, b, clamp(nodeObject(uv2)[p]));
var mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, "y");
var _split = (a, b, center, uv2, p) => mix(a, b, mx_aastep(center, nodeObject(uv2)[p]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => add(mul(uv_geo, uv_scale), uv_offset);
var mx_safepower = (in1, in2 = 1) => mul(sign(in1), pow(abs(in1), in2));
var mx_contrast = (input, amount = 1, pivot = 0.5) => add(mul(sub(input, pivot), amount), pivot);
var mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => add(mul(amplitude, mx_perlin_noise_float(convert(texcoord, "vec2|vec3"))), pivot);
var mx_noise_vec2 = (texcoord = uv(), amplitude = 1, pivot = 0) => add(mul(amplitude, mx_perlin_noise_vec2(convert(texcoord, "vec2|vec3"))), pivot);
var mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => add(mul(amplitude, mx_perlin_noise_vec3(convert(texcoord, "vec2|vec3"))), pivot);
var mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {
  texcoord = convert(texcoord, "vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(add(texcoord, vec2(19, 73))));
  return add(mul(amplitude, noise_vec4), pivot);
};
var mx_worley_noise_float2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_float(convert(texcoord, "vec2|vec3"), jitter, 1);
var mx_worley_noise_vec22 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2(convert(texcoord, "vec2|vec3"), jitter, 1);
var mx_worley_noise_vec32 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3(convert(texcoord, "vec2|vec3"), jitter, 1);
var mx_cell_noise_float2 = (texcoord = uv()) => mx_cell_noise_float(convert(texcoord, "vec2|vec3"));
var mx_fractal_noise_float2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mul(mx_fractal_noise_float(position, octaves, lacunarity, diminish), amplitude);
var mx_fractal_noise_vec22 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mul(mx_fractal_noise_vec2(position, octaves, lacunarity, diminish), amplitude);
var mx_fractal_noise_vec32 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mul(mx_fractal_noise_vec3(position, octaves, lacunarity, diminish), amplitude);
var mx_fractal_noise_vec42 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mul(mx_fractal_noise_vec4(position, octaves, lacunarity, diminish), amplitude);

// node_modules/three/examples/jsm/nodes/Nodes.js
var nodeLib = {
  // core
  ArrayUniformNode: ArrayUniformNode_default,
  AttributeNode: AttributeNode_default,
  BypassNode: BypassNode_default,
  CacheNode: CacheNode_default,
  CodeNode: CodeNode_default,
  ContextNode: ContextNode_default,
  ConstNode: ConstNode_default,
  ExpressionNode: ExpressionNode_default,
  FunctionCallNode: FunctionCallNode_default,
  FunctionNode: FunctionNode_default,
  InstanceIndexNode: InstanceIndexNode_default,
  LightingModel: LightingModel_default,
  Node: Node_default,
  NodeAttribute: NodeAttribute_default,
  NodeBuilder: NodeBuilder_default,
  NodeCache: NodeCache_default,
  NodeCode: NodeCode_default,
  NodeFrame: NodeFrame_default,
  NodeFunctionInput: NodeFunctionInput_default,
  NodeKeywords: NodeKeywords_default,
  NodeUniform: NodeUniform_default,
  NodeVar: NodeVar_default,
  NodeVarying: NodeVarying_default,
  PropertyNode: PropertyNode_default,
  StackNode: StackNode_default,
  TempNode: TempNode_default,
  UniformNode: UniformNode_default,
  VarNode: VarNode_default,
  VaryingNode: VaryingNode_default,
  // geometry
  RangeNode: RangeNode_default,
  // gpgpu
  ComputeNode: ComputeNode_default,
  // accessors
  BitangentNode: BitangentNode_default,
  BufferNode: BufferNode_default,
  CameraNode: CameraNode_default,
  CubeTextureNode: CubeTextureNode_default,
  InstanceNode: InstanceNode_default,
  MaterialNode: MaterialNode_default,
  MaterialReferenceNode: MaterialReferenceNode_default,
  ModelNode: ModelNode_default,
  ModelViewProjectionNode: ModelViewProjectionNode_default,
  NormalNode: NormalNode_default,
  Object3DNode: Object3DNode_default,
  PointUVNode: PointUVNode_default,
  PositionNode: PositionNode_default,
  ReferenceNode: ReferenceNode_default,
  ReflectVectorNode: ReflectVectorNode_default,
  SkinningNode: SkinningNode_default,
  TangentNode: TangentNode_default,
  TextureNode: TextureNode_default,
  UVNode: UVNode_default,
  UserDataNode: UserDataNode_default,
  // display
  BlendModeNode: BlendModeNode_default,
  ColorAdjustmentNode: ColorAdjustmentNode_default,
  ColorSpaceNode: ColorSpaceNode_default,
  FrontFacingNode: FrontFacingNode_default,
  NormalMapNode: NormalMapNode_default,
  PosterizeNode: PosterizeNode_default,
  ToneMappingNode: ToneMappingNode_default,
  ViewportNode: ViewportNode_default,
  // math
  MathNode: MathNode_default,
  OperatorNode: OperatorNode_default,
  CondNode: CondNode_default,
  // lighting
  PointLightNode: PointLightNode_default,
  DirectionalLightNode: DirectionalLightNode_default,
  SpotLightNode: SpotLightNode_default,
  IESSpotLightNode: IESSpotLightNode_default,
  AmbientLightNode: AmbientLightNode_default,
  LightsNode: LightsNode_default,
  LightingNode: LightingNode_default,
  LightingContextNode: LightingContextNode_default,
  HemisphereLightNode: HemisphereLightNode_default,
  EnvironmentNode: EnvironmentNode_default,
  AONode: AONode_default,
  AnalyticLightNode: AnalyticLightNode_default,
  // utils
  ArrayElementNode: ArrayElementNode_default,
  ConvertNode: ConvertNode_default,
  DiscardNode: DiscardNode_default,
  EquirectUVNode: EquirectUVNode_default,
  JoinNode: JoinNode_default,
  MatcapUVNode: MatcapUVNode_default,
  MaxMipLevelNode: MaxMipLevelNode_default,
  OscNode: OscNode_default,
  RemapNode: RemapNode_default,
  RotateUVNode: RotateUVNode_default,
  SpecularMIPLevelNode: SpecularMIPLevelNode_default,
  SplitNode: SplitNode_default,
  SpriteSheetUVNode: SpriteSheetUVNode_default,
  TimerNode: TimerNode_default,
  TriplanarTexturesNode: TriplanarTexturesNode_default,
  // procedural
  CheckerNode: CheckerNode_default,
  // fog
  FogNode: FogNode_default,
  FogRangeNode: FogRangeNode_default,
  FogExp2Node: FogExp2Node_default,
  // loaders
  NodeLoader: NodeLoader_default,
  NodeObjectLoader: NodeObjectLoader_default,
  NodeMaterialLoader: NodeMaterialLoader_default,
  // parsers
  WGSLNodeParser: WGSLNodeParser_default,
  GLSLNodeParser: GLSLNodeParser_default
};
var fromType = (type) => {
  return new nodeLib[type]();
};
export {
  AONode_default as AONode,
  AmbientLightNode_default as AmbientLightNode,
  AnalyticLightNode_default as AnalyticLightNode,
  ArrayElementNode_default as ArrayElementNode,
  ArrayUniformNode_default as ArrayUniformNode,
  AttributeNode_default as AttributeNode,
  BRDF_BlinnPhong_default as BRDF_BlinnPhong,
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  BitangentNode_default as BitangentNode,
  BlendModeNode_default as BlendModeNode,
  BufferNode_default as BufferNode,
  BypassNode_default as BypassNode,
  CacheNode_default as CacheNode,
  CameraNode_default as CameraNode,
  CheckerNode_default as CheckerNode,
  CodeNode_default as CodeNode,
  ColorAdjustmentNode_default as ColorAdjustmentNode,
  ColorSpaceNode_default as ColorSpaceNode,
  ComputeNode_default as ComputeNode,
  CondNode_default as CondNode,
  ConstNode_default as ConstNode,
  ContextNode_default as ContextNode,
  ConvertNode_default as ConvertNode,
  CubeTextureNode_default as CubeTextureNode,
  DFGApprox_default as DFGApprox,
  D_GGX_default as D_GGX,
  DirectionalLightNode_default as DirectionalLightNode,
  DiscardNode_default as DiscardNode,
  EPSILON,
  EnvironmentNode_default as EnvironmentNode,
  EquirectUVNode_default as EquirectUVNode,
  ExpressionNode_default as ExpressionNode,
  F_Schlick_default as F_Schlick,
  FogExp2Node_default as FogExp2Node,
  FogNode_default as FogNode,
  FogRangeNode_default as FogRangeNode,
  FrontFacingNode_default as FrontFacingNode,
  FunctionCallNode_default as FunctionCallNode,
  FunctionNode_default as FunctionNode,
  GLSLNodeParser_default as GLSLNodeParser,
  HemisphereLightNode_default as HemisphereLightNode,
  IESSpotLightNode_default as IESSpotLightNode,
  INFINITY,
  InstanceIndexNode_default as InstanceIndexNode,
  InstanceNode_default as InstanceNode,
  JoinNode_default as JoinNode,
  LightingContextNode_default as LightingContextNode,
  LightingModel_default as LightingModel,
  LightingNode_default as LightingNode,
  LightsNode_default as LightsNode,
  LineBasicNodeMaterial_default as LineBasicNodeMaterial,
  MatcapUVNode_default as MatcapUVNode,
  MaterialNode_default as MaterialNode,
  MaterialReferenceNode_default as MaterialReferenceNode,
  MathNode_default as MathNode,
  MaxMipLevelNode_default as MaxMipLevelNode,
  MeshBasicNodeMaterial_default as MeshBasicNodeMaterial,
  MeshPhongNodeMaterial_default as MeshPhongNodeMaterial,
  MeshPhysicalNodeMaterial,
  MeshStandardNodeMaterial,
  ModelNode_default as ModelNode,
  ModelViewProjectionNode_default as ModelViewProjectionNode,
  Node_default as Node,
  NodeAttribute_default as NodeAttribute,
  NodeBuilder_default as NodeBuilder,
  NodeCache_default as NodeCache,
  NodeCode_default as NodeCode,
  NodeFrame_default as NodeFrame,
  NodeFunctionInput_default as NodeFunctionInput,
  NodeKeywords_default as NodeKeywords,
  NodeLoader_default as NodeLoader,
  NodeMaterial_default as NodeMaterial,
  NodeMaterialLoader_default as NodeMaterialLoader,
  NodeObjectLoader_default as NodeObjectLoader,
  NodeShaderStage,
  NodeType,
  NodeUniform_default as NodeUniform,
  NodeUpdateType,
  NodeVar_default as NodeVar,
  NodeVarying_default as NodeVarying,
  NormalMapNode_default as NormalMapNode,
  NormalNode_default as NormalNode,
  Object3DNode_default as Object3DNode,
  OperatorNode_default as OperatorNode,
  OscNode_default as OscNode,
  PointLightNode_default as PointLightNode,
  PointUVNode_default as PointUVNode,
  PointsNodeMaterial_default as PointsNodeMaterial,
  PositionNode_default as PositionNode,
  PosterizeNode_default as PosterizeNode,
  PropertyNode_default as PropertyNode,
  RangeNode_default as RangeNode,
  ReferenceNode_default as ReferenceNode,
  ReflectVectorNode_default as ReflectVectorNode,
  RemapNode_default as RemapNode,
  RotateUVNode_default as RotateUVNode,
  ShaderNode,
  SkinningNode_default as SkinningNode,
  SpecularMIPLevelNode_default as SpecularMIPLevelNode,
  SplitNode_default as SplitNode,
  SpotLightNode_default as SpotLightNode,
  SpriteNodeMaterial_default as SpriteNodeMaterial,
  SpriteSheetUVNode_default as SpriteSheetUVNode,
  StackNode_default as StackNode,
  TBNViewMatrix,
  TangentNode_default as TangentNode,
  TempNode_default as TempNode,
  TextureNode_default as TextureNode,
  TimerNode_default as TimerNode,
  ToneMappingNode_default as ToneMappingNode,
  TriplanarTexturesNode_default as TriplanarTexturesNode,
  UVNode_default as UVNode,
  UniformNode_default as UniformNode,
  UserDataNode_default as UserDataNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  VarNode_default as VarNode,
  VaryingNode_default as VaryingNode,
  ViewportNode_default as ViewportNode,
  WGSLNodeParser_default as WGSLNodeParser,
  abs,
  acos,
  add,
  and,
  asin,
  assign,
  atan,
  atan2,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bmat3,
  bmat4,
  bool,
  buffer,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  checker,
  clamp,
  code,
  color,
  colorSpace,
  compute,
  cond,
  context,
  convert,
  cos,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  defaultShaderStages,
  degrees,
  densityFog,
  difference,
  diffuseColor,
  discard,
  distance,
  div,
  dodge,
  dot,
  dotNV,
  element,
  equal,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceforward,
  float,
  floor,
  fn,
  fog,
  fract,
  frameId,
  fromType,
  frontFacing,
  func,
  getDistanceAttenuation_default as getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  greaterThan,
  greaterThanEqual,
  hue,
  imat3,
  imat4,
  instance,
  instanceIndex,
  int,
  inversesqrt,
  invert,
  ivec2,
  ivec3,
  ivec4,
  label,
  length,
  lessThan,
  lessThanEqual,
  lightingContext,
  lightingModel,
  lights,
  log,
  log2,
  lumaCoeffs,
  luminance,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialColor,
  materialEmissive,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialReference,
  materialReflectivity,
  materialRotation,
  materialRoughness,
  materialShininess,
  materialSpecularColor,
  materialUV,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  mul,
  mx_aastep,
  mx_cell_noise_float2 as mx_cell_noise_float,
  mx_contrast,
  mx_fractal_noise_float2 as mx_fractal_noise_float,
  mx_fractal_noise_vec22 as mx_fractal_noise_vec2,
  mx_fractal_noise_vec32 as mx_fractal_noise_vec3,
  mx_fractal_noise_vec42 as mx_fractal_noise_vec4,
  mx_hsvtorgb,
  mx_noise_float,
  mx_noise_vec2,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_safepower,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_transform_uv,
  mx_worley_noise_float2 as mx_worley_noise_float,
  mx_worley_noise_vec22 as mx_worley_noise_vec2,
  mx_worley_noise_vec32 as mx_worley_noise_vec3,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalWorld,
  normalize,
  objectDirection,
  objectNormalMatrix,
  objectPosition,
  objectViewMatrix,
  objectViewPosition,
  objectWorldMatrix,
  or,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  overlay,
  PhongLightingModel_default as phongLightingModel,
  PhysicalLightingModel_default as physicalLightingModel,
  pointUV,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  range,
  rangeFog,
  reciprocal,
  reference,
  reflect,
  reflectVector,
  refract,
  remainder,
  remap,
  remapClamp,
  rotateUV,
  roughness,
  round,
  sampler,
  saturation,
  screen,
  shiftLeft,
  shiftRight,
  shininess,
  sign,
  sin,
  skinning,
  smoothstep,
  specularColor,
  specularMIPLevel,
  spritesheetUV,
  sqrt,
  step,
  storage,
  sub,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  temp,
  texture,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedBitangentView,
  transformedBitangentWorld,
  transformedNormalView,
  transformedNormalWorld,
  transformedTangentView,
  transformedTangentWorld,
  triplanarTexture,
  triplanarTextures,
  uint,
  umat3,
  umat4,
  uniform,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  vec2,
  vec3,
  vec4,
  vibrance,
  viewportBottomLeft,
  viewportBottomRight,
  viewportCoordinate,
  viewportResolution,
  viewportTopLeft,
  viewportTopRight,
  xor
};
//# sourceMappingURL=three_nodes.js.map
